{"componentChunkName":"component---src-templates-blog-post-js-content-file-path-home-lee-dev-side-projects-blog-content-blog-a-guide-to-usestate-and-usereducer-index-md","path":"/a-guide-to-usestate-and-usereducer/","result":{"data":{"site":{"siteMetadata":{"title":"Strings and Things","author":"Lee Warrick","siteUrl":"https://leewarrick.com/blog"}},"mdx":{"id":"b4b75ea1-ccad-547d-86fe-3e5a8f2bc932","excerpt":"Redux is one of those technologies that I consider a “personal Everest”. Everytime I look at it, I feel like there’s no end to the boilerplate and patterns to memorize. At my…","frontmatter":{"title":"Bridging the Gap between React's useState, useReducer, and Redux","date":"September 12, 2019"},"body":"\n![Photo of a man carelessly leaping over a very deep chasm by Alex Radelich](./mindthegap.jpg)\n\nRedux is one of those technologies that I consider a \"personal Everest\". Everytime I look at it, I feel like there's no end to the boilerplate and patterns to memorize.\n\nAt my first job and the first codebase I worked on, we had to use NGRX (Angular's version of Redux). It was incredibly challenging; I spent hours reading docs and watching tutorials trying to understand NGRX. I even tried learning Redux in a desperate attempt to understand NGRX. I constantly complained to my boss about all the boilerplate, files, and patterns to memorize.\n\nHe told me, _\"If you were to use your own solution instead, you'd probably end up repeating those same patterns anyway\"._\n\nI finally concede. After managing React state with everything _except_ Redux, I've found myself appreciating why it works the way it does and requires so much boilerplate. After learning React's Context API, `useReducer` and a lot more about managing state, I finally appreciate Redux.\n\nIt's not easy getting from A to B though. There's a lot of ground to cover between learning `useState` and `useReducer`, and even more when you get into Redux and managing complicated states.\n\n## The 'useState' Hook\n\nReact's `useState` is a pleasure to use. Give it an initial value, and it gives you a reference to the reactive value and a setter function to update that value.\n\nHere's the classic counter example with `useState`:\n\n```jsx react-live\nfunction Counter() {\n    const [count, setCount] = React.useState(0)\n    return (\n        <div>\n            <p>Count: {count}</p>\n            <button onClick={() => setCount(count + 1)}>\n                Increment\n            </button>\n        </div>\n    )\n}\n```\n\nSimple enough! There's only two quirks:\n\nThe first is that you must provide a new state value to the `setCount` function (`setCount(count++)` and `count++` won't work). React is steeped in immutability, meaning you should always return a new value instead of changing the current value.\n\nThe other quirk is the returned array, but almost all hooks follow this pattern. It's a small price to pay considering how easy it is to write functional hook components compared to class components.\n\nSo while `useState` seems simple enough, what happens when you need more than a single state value? What if you have a form with multiple fields?\n\nLuckily, with hooks we can use `useState` multiple times:\n\n```jsx react-live use-render\nfunction FormExample() {\n  const [email, setEmail] = React.useState('')\n  const [name, setName] = React.useState('')\n\n  const columnStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n  return (\n    <form style={{ ...columnStyle, width: '300px' }}>\n      <label style={columnStyle}>\n        <span>Name:</span>\n        <input\n          onChange={e => setName(e.target.value)}\n          value={name}\n          type=\"text\"\n        />\n      </label>\n      <label style={columnStyle}>\n        <span>Email:</span>\n        <input\n          onChange={e => setEmail(e.target.value)}\n          value={email}\n          type=\"text\"\n        />\n      </label>\n      <pre>{JSON.stringify({name, email}, null, 2)}</pre>\n    </form>\n  )\n}\nrender(FormExample)\n```\n\nGreat! But how much is too much with `useState`? Is there a sensible limit? Should we keep it to 5 or less?\n\nAnd what if you need to manage more complicated data structures or perform side effects?\n\n## The 'useReducer' Hook\n\n![Photo of a man stirring a campfire cooking pot by Gary Sandoz](./cooking.jpg)\n\nNow we've entered `useReducer` territory. The reducer in 'useReducer' comes from Redux, which in turn borrowed it from JavaScript's `Array.reduce()`.\n\nSo what does it mean to \"reduce\" something? Think of simmering balsamic vinegar so the vinegar evaporates and you're left with a sweet, delicious glaze. That's called a \"balsamic reduction\". Think of reducers as taking arguments and cooking them down until they're more pallatable.\n\nIn the context of React, here's the typical pattern used with `useReducer`:\n\n```js\nconst reducer = function (currentState, action) {\n  // Make a new state based on the current state and action\n  // Note: There's usually a big switch statement here\n  return newState\n}\nconst [state, dispatch] = useReducer(reducer, initialValue)\n\n// example usage:\ndispatch({type: \"THING_HAPPENED\"})\n// Or with an optional \"payload\":\ndispatch({type: \"THING_HAPPENED\", payload: newData})\n```\n\nBefore we dig into the classic reducer pattern, I want to boil `useReducer` down to its basic functionality. Simply put: `useReducer` is almost identical to `useState`, except `useReducer` lets you define exactly how to update it's state value by passing it a function.\n\nLet's look at our counter example from before. Here we'll implement our own `useState` with `useReducer`:\n\n```jsx react-live\nfunction Counter() {\n    const [count, setCount] = React.useReducer((currentCount, newCount) => newCount, 0)\n    return (\n        <div>\n            <p>Count: {count}</p>\n            <button onClick={() => setCount(count + 1)}>\n                Increment\n            </button>\n        </div>\n    )\n}\n```\n\nThis is extra work with no benefit, though. Why pass a function to `useReducer`, only to pass another to `onClick`? Also, our counter logic is living in our JSX button element, which isn't great.\n\nLet's cut out the extra function and move our logic out of the JSX:\n\n```jsx react-live\nfunction Counter() {\n    const [count, increment] = React.useReducer(currentCount => currentCount + 1, 0)\n    return (\n        <div>\n            <p>Count: {count}</p>\n            <button onClick={increment}>\n                Increment\n            </button>\n        </div>\n    )\n}\n```\n\nIf you take nothing else away from this article, remember this:\n\n**The power of `useReducer` is that it allows us to define how we update our state value.**\n\nThat said, before we dive further into reducers and patterns, I want to take a minute to define \"state\".\n\n## The Problem with \"State\" in React\n\nThere are some major misconceptions about \"state\" in React. I think when Vue named it's version of state \"data\", they made it easier to think about Vue code.\n\nWhat React defines as state is really just data that we would normally store in variables. However, React needs to, well, _react_ to changes in that data. So under the hood, when you store things in state, React attaches methods and properties to that object so it knows when to trigger re-renders.\n\n**React \"state\" is just an object that React watches for updates.**\n\nSo if React's \"state\" isn't really state, what is? The concept of \"state\" actually pre-dates React by [decades](https://en.wikipedia.org/wiki/State_(computer_science)). In computer science terms, **the state of an application describes its current status and the previous events and user interactions that resulted in that status.**\n\nThis type of state is notoriously difficult to deal with in programming. This is why every technical support agent defaults to \"turn it off and on again\" when you call for help. Your device entered a bad state somehow, and sometimes the easiest way to get out of a bad state is to reboot the system into a new state.\n\nWhen we write React code, the problem is that we have a tendency to conflate the state of the program with the data React is watching for renders. For example, you might have data in your component that describes what the user typed in an input field, but also data that tells you if the form is valid or not. The combination of that current data and how it changed in response to the user is the actual state of your component.\n\nWe typically only worry about storing and updating data in our components, and avoid thinking about it's actual state until we start to find bugs.\n\n## Reducers and Redux\n\nThe reducer pattern is an attempt to tame the flow of updating complex state. While not foolproof or easy, it can help us define and manages state changes in our application and components.\n\nLet's look at a simple version of the reducer pattern in the context of a form:\n\n```js\nconst reducer = function (currentState, action) {\n    switch(action.type) {\n        case 'NAME_CHANGED':\n            return {...currentState, name: action.payload}\n        case 'EMAIL_CHANGED':\n            return {...currentState, email: action.payload}\n        default:\n            return state\n    }\n}\nconst [state, dispatch] = useReducer(reducer, {name: '', email:''})\n\n// example usage:\ndispatch({type: 'NAME_CHANGED'})\n// or with a payload:\ndispatch({type: 'NAME_CHANGED', payload: 'Suzy'})\n```\n\nThink about this as an event signaling system. When we call `dispatch`, we pass in an object that tells us what happened, and then our reducer takes that information and processes it to create a new state.\n\nSo why call it dispatch and action? Why the switch statement?\n\n### Dispatchers\n\nI like to picture `dispatch` as a dispatcher of an old switchboard telephone system. The dispatcher packages the info with the main message (type) and any additional info (payload) and plugs it into the switchboard, our reducer (which coincidentally contains a `switch`).\n\n### Actions\n\n[They really should have called them \"events\" instead of \"actions\".](https://medium.com/magnetis-backstage/why-action-is-a-bad-name-for-a-redux-action-68bec375539e) Actions describe events that have happened in your application. So when naming action types, it's better to use the past tense ie `\"NAME_CHANGED\"`, than the present, ie `\"CHANGE_NAME\"`.\n\nWhile this may seem like irrelevant semantics, it makes a big difference in understanding the redux pattern. It's important to remember that your reducer is responding to events to decide on a new state. When you say `\"CHANGE_NAME\"`, you're implying that your reducer _will_ change the name, as opposed to letting it decide _if_ it will change it.\n\n**Note:** While I would much rather refer to these as events, we'll stick with \"action\" for sake of convention. Just remember to use the past tense in your action types.\n\n**Another Note:** We also use [SCREAMING_SNAKE_CASE](https://en.wikipedia.org/wiki/Snake_case) for our action types. This is to denote that the strings are a constant value and to also implore you not to mutate or change them. (\"Screaming Snake Case\" is an excellent name for a metal band, btw.)\n\n### The Switch Statement\n\nThe choice of a switch statement over a long `if`/`else if` chain is mainly about readability.\n\nYou may also notice that there's no `break` statements and lots of spread operators in our switch statement. We're using `return` in lieu of break, which prevents the switch waterfall effect (more on that later). As for the spread operators, remember that React is built on immutability, so the creation of new objects is necessary. By spreading first and passing in our changes second, we can overwrite only the properties in state that we need to without affecting the rest:\n\n```js js-live autorun\nconst state = {\n  name: \"Robert\",\n  email: \"SuperBobby74@aol.com\"\n}\nconst newState = {...state, name: \"Bobby\"}\nconsole.log(newState)\n```\n\nLet's apply the reducer pattern and `useReducer` to our form from earlier:\n\n```jsx react-live use-render\nfunction FormExample() {\n  function formReducer(state, action) {\n    switch (action.type) {\n      case 'NAME_CHANGED':\n        return { ...state, name: action.payload }\n      case 'EMAIL_CHANGED':\n        return { ...state, email: action.payload }\n      default:\n        return state\n    }\n  }\n\n  const [state, dispatch] = React.useReducer(formReducer, {\n    name: '',\n    email: '',\n  })\n\n  const columnStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n\n  return (\n    <form style={{ ...columnStyle, width: '300px' }}>\n      <label style={columnStyle}>\n        <span>Name:</span>\n        <input\n          onChange={e =>\n            dispatch({ type: 'NAME_CHANGED', payload: e.target.value })\n          }\n          value={state.name}\n          type=\"text\"\n        />\n      </label>\n      <label style={columnStyle}>\n        <span>Email:</span>\n        <input\n          onChange={e =>\n            dispatch({ type: 'EMAIL_CHANGED', payload: e.target.value })\n          }\n          value={state.email}\n          type=\"text\"\n        />\n      </label>\n      <pre>{JSON.stringify(state, null, 2)}</pre>\n    </form>\n  )\n}\n\nrender(FormExample)\n```\n\nThis works great, but we can make some improvements.\n\nFirst let's pull our action types out and make them into an object like this:\n\n```js\nconst actions = {\n  nameChanged: 'NAME_CHANGED',\n  emailChanged: 'EMAIL_CHANGED',\n}\n```\n\nThis will save you from errors down the line. If you use `actions.nameChanged` in your switch and dispatch, your IDE may help prevent errors from typos in your action types. (You might see this same pattern with enums if the codebase is using TypeScript.)\n\nWe can also pull out our initial state into it's own object, and move it outside of our component along with our reducer and our actions.\n\n```jsx react-live use-render\nconst actions = {\n  nameChanged: 'NAME_CHANGED',\n  emailChanged: 'EMAIL_CHANGED',\n}\n\nconst initialState = {\n  name: '',\n  email: '',\n}\n\nfunction formReducer(state, action) {\n  switch (action.type) {\n    case actions.nameChanged:\n      return { ...state, name: action.payload }\n    case actions.emailChanged:\n      return { ...state, email: action.payload }\n    default:\n      return state\n  }\n}\n\nfunction FormExample() {\n  const [state, dispatch] = React.useReducer(formReducer, initialState)\n\n  const columnStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n  return (\n    <form style={{ ...columnStyle, width: '300px' }}>\n      <label style={columnStyle}>\n        <span>Name:</span>\n        <input\n          onChange={e =>\n            dispatch({ type: actions.nameChanged, payload: e.target.value })\n          }\n          value={state.name}\n          type=\"text\"\n        />\n      </label>\n      <label style={columnStyle}>\n        <span>Email:</span>\n        <input\n          onChange={e =>\n            dispatch({ type: actions.emailChanged, payload: e.target.value })\n          }\n          value={state.email}\n          type=\"text\"\n        />\n      </label>\n      <pre>{JSON.stringify(state, null, 2)}</pre>\n    </form>\n  )\n}\nrender(FormExample)\n```\n\n### Handling Business Logic using Reducers\n\nYou might be wondering why exactly we've taken our `useState` example and made it so complicated. It seems like all we've done is add code to duplicate the same functionality we had before.\n\nReducers really start to shine when we add a submit button to the form. Forms are devilishly complex things to reason about (lots of state to manage), which is why there are so many form libraries out there. You need to account for validation, plus keep track of what fields are filled out, what happens when the form is submitted, etc.\n\nIf you were going to manage that logic with `useState`, you'd find yourself wrapping your submit in a lot of code, adding more `useState` hooks, and possibly wrapping your setter functions in validation functions that might update _other_ state values. This would get messy quickly.\n\nUnlike `useState`, `useReducer` provides a great infrastructure to handle all of the logic that surrounds validation and submission:\n\n```jsx react-live use-render\nconst actions = {\n  nameChanged: 'NAME_CHANGED',\n  emailChanged: 'EMAIL_CHANGED',\n  formSubmitted: 'FORM_SUBMITTED',\n}\n\nconst initialState = {\n  name: '',\n  email: '',\n  nameError: null,\n  emailError: null,\n  formCompleted: false,\n  formSubmitted: false,\n}\n\nfunction formReducer(state, action) {\n  let error\n  switch (action.type) {\n    case actions.nameChanged:\n      error = validate('name', action.payload)\n      return { ...state, name: action.payload, nameError: error }\n    case actions.emailChanged:\n      error = validate('email', action.payload)\n      return { ...state, email: action.payload, emailError: error }\n    case actions.formSubmitted:\n      // if the form has been successfully submitted,\n      // stop here to prevent rage clicks and re-submissions\n      if (state.formCompleted) return state\n      let formValid = true\n      // invalidate the form if values are missing or in error\n      if (state.nameError || !state.name || state.emailError || !state.email) {\n        formValid = false\n      }\n      // if the user has attempted to submit before, stop here\n      if (state.formSubmitted) return { ...state, formCompleted: formValid }\n      // if this is the first submit, we need to validate in case the user\n      // clicked submit without typing anything\n      let nameError = validate('name', state.name)\n      let emailError = validate('email', state.email)\n      return {\n        ...state,\n        nameError,\n        emailError,\n        formSubmitted: true,\n        formCompleted: formValid,\n      }\n    default:\n      return state\n  }\n}\n\n// this helper function validates the name and email inputs\n// if there's an error, it returns an error message describing the problem\n// if there are no errors, it returns null\n// it's outside our reducer to make things more readable and DRY\nfunction validate(name, value) {\n  if (typeof value === 'string') value = value.trim()\n  switch (name) {\n    case 'name':\n      if (value.length === 0) {\n        return 'Must enter name'\n      } else if (value.split(' ').length < 2) {\n        return 'Must enter first and last name'\n      } else {\n        return null\n      }\n      break\n    case 'email':\n      if (value.length === 0) {\n        return 'Must enter email'\n      } else if (\n        !value.includes('@') ||\n        !value.includes('.') ||\n        value.split('.')[1].length < 2\n      ) {\n        return 'Must enter valid email'\n      } else {\n        return null\n      }\n      break\n  }\n}\n\nfunction FormExample() {\n  const [state, dispatch] = React.useReducer(formReducer, initialState)\n\n  // extract our dispatch to a change handler to DRY the code up\n  function handleChange(e) {\n    dispatch({ type: actions[e.target.name + 'Changed'], payload: e.target.value })\n  }\n\n  // this is attached to the form, not the submit button so that\n  // the user can click OR press 'enter' to submit\n  // we don't need a payload, the input values are already in state\n  function handleSubmit(e) {\n    e.preventDefault()\n    dispatch({ type: actions.formSubmitted })\n  }\n\n  const columnStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n  // this adds a red outline to the input if the field isn't filled out correctly,\n  // but only if the user has attempted to submit\n  const inputStyle = hasError => {\n    return {\n      outline: hasError && state.formSubmitted ? '2px solid red' : 'none',\n    }\n  }\n  return (\n    <form style={{ ...columnStyle, width: '300px' }} onSubmit={handleSubmit}>\n      <label style={columnStyle}>\n        <span>Name:</span>\n        <input\n          style={inputStyle(state.nameError)}\n          onChange={handleChange}\n          name=\"name\"\n          value={state.name}\n          type=\"text\"\n        />\n        <span>{state.formSubmitted && state.nameError}</span>\n      </label>\n      <label style={columnStyle}>\n        <span>email:</span>\n        <input\n          style={inputStyle(state.emailError)}\n          onChange={handleChange}\n          name=\"email\"\n          value={state.email}\n          type=\"text\"\n        />\n        <span>{state.formSubmitted && state.emailError}</span>\n      </label>\n      <p>{state.formCompleted && 'Form Submitted Successfully!'}</p>\n      <button type=\"submit\">Submit</button>\n      <pre>{JSON.stringify(state, null, 2)}</pre>\n    </form>\n  )\n}\n\nrender(FormExample)\n```\n\nNotice how our reducer function swelled with business logic. That's OK! In fact, it's a good rule of thumb to keep your reducers fat and event handlers skinny.\n\nThe functionality has changed as well. As our values change, the reducer handles validation and adds error messages to our state if necessary. If the form hasn't been submitted, we can hold off on annoying the user with red boxes and error messages until they submit. If errors are present on submission, we can change the messages as they type to guide them to enter the correct information. Lastly, we can prevent rage clicks and repeat submissions with a `formCompleted` flag in our submission case.\n\nThis provides a great experience for the user, and a good organizational model for all these complex UI interactions.\n\n## Welcome to Redux\n\nBelieve it or not, **We've now implemented all the major components of Redux**. Redux itself is really just a helper library to assist in doing the same things we've done in this article.\n\nIn a typical Redux application, we lift the **actions**, **reducers**, and **state** into their own files in the project. To manage multiple state objects, we can group sets of actions/reducers/state into different **stores** that then become part of a **global store** with a **root reducer**. The root reducer's job is to compose the state of each store into a single, global state object.\n\nThen we import whatever store, dispatcher, and actions we need into our components to access state and signal events to the global store. Redux provides some utility to assist in composing this global state management system, but for the most part, you're going to write all the actions, reducers, and states yourself, just like we did in this article.\n\nSo if you made it this far, you're ready to use Redux! The real question is, should you?\n\n### Is Redux Dead ☠?\n\nYou can certainly do a lot without Redux nowadays with the Context API and the information learned here. Think of a Context as a Redux Store that you can position anywhere in your app. Any components that are wrapped in a Context Provider get access to the values you share from it. Context can be at the top level in your application, providing state to everything, or further down and only sharing its state with a handful of components.\n\nKent C Dodds has an **excellent** [article](https://kentcdodds.com/blog/application-state-management-with-react) on using Context for state management in React.\n\nThat said, **Redux is not dead**. There are plenty of codebases out there using it, and if you're going to write React professionally, it's not a bad idea to learn it.\n\n## Beyond Redux 😵\n\nWe're going to get into some slightly advanced topics now, so buckle up.\n\nThe most astute tester might have noticed the **bug in the last example.** Scroll up and see if you can't find the edge case we missed.\n\nGive up?\n\n**You can edit the form after a successful submit!**\n\nHow can we fix this? Your first instinct might be to start sprinkling the `formSubmitted` flag throughout our reducer to prevent further changes to the form, sort of how we did at the beginning of our submit case.\n\nThis would work, but it's hard to read and reason about. I'd argue that the submission case is already a bit of a mess, and adding more logic to the other cases is only going to make things worse.\n\nMore importantly, how did we miss this in the first place? We learned all of this complicated JavaScript to prevent bugs, but we found some anyway!\n\n## Implicit vs Explicit States\n\nIn my tangent on state, I mentioned that we sometimes end up describing state with booleans or flags in our code. We've done that in our form with `formCompleted` and `formSubmitted`. The problem is that we've implicitly described the state of our form instead of explicitly.\n\nThat means that we're relying on some combination of those booleans to describe the state of our form. For example, if the user hasn't entered anything and hasn't pressed submit, we might write:\n\n```js\nif (!formSubmitted && !name && !email && !emailError && !nameError) {\n  // behave as if user hasn't done anything yet\n}\n```\n\nThis is messy and hard to understand. When you come back to this code later you might even forget how it works and be hesitant to change it. It's much better to explicitly describe the state of the form, and then ensure that the form can only exist in one of those states at any point in time.\n\nWe could describe our form states as:\n\n* **Clean** - User hasn't entered anything or pressed submit\n* **Dirty** - User has started to enter info, but hasn't successfully finished and submitted\n* **Completed** - Form has been filled out correctly and submitted\n\nWe also want to handle the transitions between these states as well as the possible actions that can happen in each state:\n\n* **Clean** - User hasn't entered anything or pressed submit\n  * Possible Transitions: Dirty\n  * Allowed Actions: editing and submitting, but submitting does not trigger errors, just a message\n* **Dirty** - User has started to enter info, but hasn't successfully finished and submitted\n  * Possible Transitions: Completed\n  * Allowed Actions: editing and submitting, but submitting triggers error messages\n* **Completed** - Form has been filled out correctly and submitted\n  * Possible Transitions: None!\n  * Allowed Actions: None!\n\n## Finite State Machines\n\nThe mental model we just created is a state machine or finite state machine (FSM). **Finite** meaning there's a limited amount of states that the form can exist in, **state** describing the status of the form, and **machine** referring to the mechanism of how we transition to and from different states.\n\nI'm not a state machine expert, so I highly recommend reading [these](https://medium.com/@DavidKPiano/the-facetime-bug-and-the-dangers-of-implicit-state-machines-a5f0f61bdaa2) [articles](https://24ways.org/2018/state-machines-in-user-interfaces/) by David Khourshid for a deeper dive into FSMs.\n\nThere are two options for applying this model to our code.\n\nFirst, there's library that's tailor-made for FSMs called [XState](https://xstate.js.org/docs/), written by the same David mentioned above. Here's a great [tutorial](https://gedd.ski/post/state-machines-in-react/) by Dave Geddes on using xstate in React if you're interested.\n\nThe other option is to implement the logic ourselves in our reducer. This is a bit of a tall order, but if you read the FSM articles I linked, you might have seen an example of a FSM implemented with a **nested switch** statement. Let's apply that to our form.\n\n### Advanced Switch Statements\n\nBefore we get to our final example, let's briefly review JavaScript's `switch`.\n\nWhat we're about to use is the \"fall-through\" or \"waterfall\" switch usage. What this means is we will deliberately _not_ use `break` in every case so that we can match multiple cases.\n\nLet's see an example where we ignore Mom's advice and skip breakfast, but still eat lunch and dinner:\n\n```js js-live autorun\nconst actionType = \"LUNCH_ORDERED\"\n\nswitch(actionType) {\n  case \"BREAKFAST_ORDERED\":\n    console.log(\"breakfast\")\n    // no break!\n  case \"LUNCH_ORDERED\":\n    console.log(\"lunch\")\n    // no break!\n  case \"DINNER_ORDERED\":\n    console.log(\"dinner\")\n    break\n  default:\n    console.log(\"fasting 😵\")\n}\n```\n\n**Once you match a case, you match all cases until you break or return.**\n\nWhat about nested switches 😵?\n\n```js js-live autorun\nfunction dailyLife(status, actionType) {\n  switch(status) {\n    case \"work\":\n      switch(actionType) {\n        case \"WORK_REQUESTED\":\n          console.log(\"DOING WORK\")\n          break\n      }\n    //no break after \"work\"\n    case \"holiday\":\n      switch(actionType) {\n        case \"CAKE_EATEN\":\n          console.log(\"FEELING FAT\")\n          break\n        case \"NAP_REQUESTED\":\n          console.log(\"NAPPING\")\n          break\n      }\n  }\n}\nconsole.log(\"ooooh, who's birthday is it?\")\ndailyLife(\"work\", \"CAKE_EATEN\") // feeling fat\n\nconsole.log(\"Taking a break, afk\")\ndailyLife(\"work\", \"NAP_REQUESTED\") // napping\n\nconsole.log(\"Hey, I know it's Saturday, but can you get us that TPS report?\")\ndailyLife(\"holiday\", \"WORK_REQUESTED\") // not happening, sorry boss\n```\n\nHere we can see that you can take a nap at work and on holiday, but you can't work on a holiday. (At least you shouldn't).\n\nThe idea is that if you have to share actions between states, **put the state with unshared actions at the top**. If we can only work at work, then the work status should be at the top. If you can eat cake at work and on holiday, then holidays/cake-eating should be below.\n\nThis is definitely an advanced technique, so be careful and test often when you're writing a complicated switch that's nesting and waterfalling through cases.\n\nIn the case of our form, we want the user to be able to edit the form regardless if it's \"clean\" or \"dirty\". To share the input change actions, we don't `break` between the clean and dirty cases so that those actions are available to both. Also, you can submit in both states, but submit behaves differently in each.\n\nAlright, here we go! Let's take a look at our final form example with FSMs and `useReducer`:\n\n```jsx react-live use-render\nconst actions = {\n  nameChanged: 'NAME_CHANGED',\n  emailChanged: 'EMAIL_CHANGED',\n  formSubmitted: 'FORM_SUBMITTED',\n}\n\nconst initialState = {\n  name: '',\n  email: '',\n  nameError: null,\n  emailError: null,\n  submitAttempted: false,\n  submitMessage: '',\n  status: 'clean',\n}\n\nfunction formReducer(state, action) {\n  let error\n  switch (state.status) {\n    case 'dirty':\n      switch (action.type) {\n        case actions.formSubmitted:\n          let formValid = true\n          let nameError = validate('name', state.name)\n          let emailError = validate('email', state.email)\n          if (nameError || !state.name || emailError || !state.email) {\n            formValid = false\n          }\n          return {\n            ...state,\n            nameError,\n            emailError,\n            submitAttempted: true,\n            status: formValid ? 'completed' : 'dirty',\n            submitMessage: formValid\n              ? 'Form Submitted Successfully'\n              : 'Form Has Errors',\n          }\n      }\n    // no 'break' or 'return', case 'dirty' continues!\n    case 'clean':\n      switch (action.type) {\n        case actions.nameChanged:\n          error = validate('name', action.payload)\n          return {\n            ...state,\n            name: action.payload,\n            nameError: error,\n            submitMessage: '',\n            status: 'dirty',\n          }\n        case actions.emailChanged:\n          error = validate('email', action.payload)\n          return {\n            ...state,\n            email: action.payload,\n            emailError: error,\n            submitMessage: '',\n            status: 'dirty',\n          }\n        case actions.formSubmitted:\n          return {\n            ...state,\n            submitMessage: 'Please fill out the form',\n          }\n        default:\n          return state\n      }\n    case 'completed':\n    // no 'break' or 'return', case 'completed' continues!\n    default:\n      return state\n  }\n}\n\nfunction validate(name, value) {\n  if (typeof value === 'string') value = value.trim()\n  switch (name) {\n    case 'name':\n      if (value.length === 0) {\n        return 'Must enter name'\n      } else if (value.split(' ').length < 2) {\n        return 'Must enter first and last name'\n      } else {\n        return null\n      }\n      break\n    case 'email':\n      if (value.length === 0) {\n        return 'Must enter email'\n      } else if (\n        !value.includes('@') ||\n        !value.includes('.') ||\n        value.split('.')[1].length < 2\n      ) {\n        return 'Must enter valid email'\n      } else {\n        return null\n      }\n      break\n  }\n}\n\nfunction FormExample() {\n  const [state, dispatch] = React.useReducer(formReducer, initialState)\n\n  function handleChange({ target: { name, value } }) {\n    dispatch({ type: actions[name + 'Changed'], payload: value })\n  }\n\n  function handleSubmit(e) {\n    e.preventDefault()\n    dispatch({ type: actions.formSubmitted })\n  }\n\n  const columnStyle = {\n    display: 'flex',\n    flexDirection: 'column',\n  }\n  const inputStyle = hasError => {\n    return {\n      outline: hasError && state.submitAttempted ? '2px solid red' : 'none',\n    }\n  }\n  return (\n    <form style={{ ...columnStyle, width: '300px' }} onSubmit={handleSubmit}>\n      <label style={columnStyle}>\n        <span>Name:</span>\n        <input\n          style={inputStyle(state.nameError)}\n          onChange={handleChange}\n          name=\"name\"\n          value={state.name}\n          type=\"text\"\n        />\n        <span>{state.submitAttempted && state.nameError}</span>\n      </label>\n      <label style={columnStyle}>\n        <span>email:</span>\n        <input\n          style={inputStyle(state.emailError)}\n          onChange={handleChange}\n          name=\"email\"\n          value={state.email}\n          type=\"text\"\n        />\n        <span>{state.submitAttempted && state.emailError}</span>\n      </label>\n      <p>{state.submitMessage}</p>\n      <button type=\"submit\">Submit</button>\n      <pre>{JSON.stringify(state, null, 2)}</pre>\n    </form>\n  )\n}\n\nrender(FormExample)\n```\n\nNow our form is bug free!\n\nWe've explicitly modeled and accounted for all the possible states it can exist in, and defined the possible actions in those states.\n\n**Note:** You may notice we still have a `submitAttempted` boolean in the code. This is OK because it is only used to show or hide the error messages in our form. Most importantly, **We don't check `submitAttempted` to determine what state we're in.**\n\n## Parting Thoughts\n\nThis post is full of advanced concepts and I hope that you were able to learn some of them even if you didn't make it all the way to the end. **Don't fret if you didn't understand every concept and example.** Start at the easy stuff, and start applying and practicing those concepts first in your own code before moving on to the more difficult concepts. That's how I learned them.\n\nThanks for reading this huge article, cheers!"}},"pageContext":{"slug":"/a-guide-to-usestate-and-usereducer/","previous":{"id":"31f2401f-7ef0-58c0-a5b4-a86f672d574d","fields":{"slug":"/react-use-effect-explained/"},"frontmatter":{"title":"React's useEffect and useRef Explained for Mortals"},"body":"\n![Photo of the Acropolis of Athens, Athens, Greece by Cristina Gottardi](./acropolis.jpg)\n\nIf the React docs leave you in the dust, or Dan Abramov's [blog](https://overreacted.io/a-complete-guide-to-useeffect/) makes you feel like you're reading a scroll handed down from Mt Olympus written in ancient Greek, you're not alone.\n\nSometimes the pantheon of React Gods have a hard time translating their wisdom into language the rest of us can understand. It usually goes like this: You hit a snag with React, google your issue, and read a blog or Stack Overflow post with some advice that makes you feel more lost than when you started.\n\nI've certainly fallen victim to this many, many times. Particularly with `useEffect`. Before we dive into this particular hook, let me say that I love writing React with hooks and wouldn't want to go back to classes. That said, `useEffect` is a big pain point.\n\n## What is an \"effect\" anyway?\n\nTo really wrap your head around `useEffect`, let's back up a little bit and talk about programming and JavaScript.\n\nThe effects that `useEffect` is named for are what we affectionately refer to as \"side effects\".\n\nSo what is a side effect? It's a bit of code that reaches out and ...does something else. It's an abstract concept, so let's talk in examples.\n\nHere's a function with NO side effects:\n\n```js\nfunction add(a, b) {\n    return a + b\n}\n```\n\nThe function `add` does nothing except take an input and return an output. It doesn't reach outside itself to mess with anything else!\n\nLet's introduce a side effect.\n\n```js js-live autorun linkId=\"ex1\" no-edit\nconst resultDiv = document.getElementById('add-example')\nfunction add(a, b) {\n    const result = a + b\n    resultDiv.textContent = `The Result is ${result}`\n    return a + b\n}\nadd(3, 4)\n```\n\n```html html-live linkId=\"ex1\" no-edit\n<div id=\"add-example\"></div>\n```\n\nNow our function reaches outside of itself to update the DOM (short for [Document Object Model](https://www.youtube.com/watch?v=H63dVFDuJDM)) and show the result. This additional behavior is a side effect.\n\n## Side Effects in React\n\nSo what about React? It's a library that pretty much only updates the DOM. A view library, if you will. So what would you call a side effect in React?\n\nAnything outside of updating the page. If you're not using React to update state or render HTML, that's a side effect. It's any non-React thing.\n\nThis means anytime you call an API, use `setInterval`/`setTimeout`, add a keyboard listener, or really anytime you mess with the `window` object you're introducing side effects.\n\nHooks are amazing and let you write really readable, reusable code... except when you're dealing with side effects. And that's unfortunate, because when you think about it, most of the fun, interesting stuff we do as web developers revolves around side effects.\n\nLet's take a step back from hooks for a minute and look at how we would handle side effects in class-based components.\n\n### Class-based Components and Side Effects\n\nIn class-based components, we would use lifecycle methods to perform side effects. For example, on `componentDidMount` we would call APIs to get data for render.\n\n_\"Why not call the API in the constructor function?\"_, you might ask. Well, because React says stuff we use for render goes in \"state\" and we can't mess with state until our component is loaded onto the page. If we try to update state before the component is loaded, we get errors.\n\nHere's a typical class-based component hitting the [PokeAPI](https://pokeapi.co/):\n\n```jsx react-live no-edit\nclass Pokemon extends React.Component {\n    constructor() {\n        super()\n        this.state = null\n    }\n    componentDidMount() {\n        fetch('https://pokeapi.co/api/v2/pokemon/gengar/')\n        .then(res => res.json())\n        .then(res => {\n            this.setState(res)\n        })\n    }\n    render() {\n        const pokemon = this.state\n        const style = {textTransform: 'capitalize'}\n        return (\n            <div>\n            { pokemon\n                ? <>\n                    <img src={pokemon.sprites.front_default}\n                        alt={'Image of ' + pokemon.name}/>\n                    <p style={style}>Name: {pokemon.name}</p>\n                    <p style={style}>\n                        Type: {pokemon.types.map(x => x.type.name).join(', ')}\n                    </p>\n                </>\n                : 'Loading...'\n            }\n            </div>\n        )\n    }\n}\n```\n\nThis works well, except when it doesn't. What happens when we want to hit the API again to grab a different pokemon? What if this component is attached to a certain route in our app and the route changes, but the component doesn't unmount/remount. What if the user goes to a different page and the component unmounts before the API call finishes?\n\nThe answer is to add more lifecycle methods like `componentDidUpdate` and `componentWillUnmount` to perform more API calls and prevent weird unmounting errors. So we add those lifecycle methods in to handle all our edge cases. And by the time we're done, we realize most of our component consists of lifecycle code.\n\n## Then Came React Hooks\n\nThe React team realized that the class API is a little unwieldy and hard to reason about. People were making [lifecycle flowcharts](https://levelup.gitconnected.com/componentdidmakesense-react-lifecycle-explanation-393dcb19e459) trying to understand the inner workings of React ...it was a mess.\n\nSo at ReactConf in October of 2018, after Sophie Alpert outlined just how bad classes are to use, Dan Abramov got on stage and introduced hooks (You can watch the video [here](https://youtu.be/dpw9EHDh2bM?t=643)).\n\nHooks introduced statefulness in functional components, as well as a new way to handle side effects. Hooks made React code more reusable with less code--a huge win!\n\nExcept for one small quirk. Each render, the whole component/function is re-run.\n\nLet's look at an example of a hooks-based component:\n\n```jsx react-live no-edit\nfunction RerenderExample() {\n    const [bool, setBool] = React.useState(false)\n    const randomNum = Math.random()\n    return (\n        <div>\n            <p>This number will be different each time you click the button:</p>\n            <p>{randomNum}</p>\n            <button onClick={() => setBool(!bool)}>Trigger a render</button>\n        </div>\n    )\n}\n```\nWe're not even using `bool` in our rendered JSX, yet the whole function runs everytime the state changes. **Every render, everything inside the component re-runs: function definitions, variable creation/assignment, etc.**\n\nIf you're thinking _\"what if I have to do something computationally expensive inside a component? This can't be performant...\"_, that's an astute observation. An expensive operation in a functional component _wouldn't_ be performant. In fact `useCallback` and `useMemo` exist as escape hatches for this very problem. Kent C Dodds has a challenging read on those [here](https://kentcdodds.com/blog/usememo-and-usecallback), but to summarize, according to Kent you shouldn't worry about the re-renders until you see performance impacts.\n\n(**Note**: If you're unfamiliar with hooks, bookmark that article and come back to it when you're ready. Don't worry about memoization until you have to.)\n\nHooks like `useState` employ some magic under-the-hood to avoid the re-render problem. That's great, and it seems simple enough using `useState`, but what about when you need to do things outside of setting state?\n\nEnter `useEffect`. Gone are those pesky lifecycle methods, hooray! However this hook comes with its own weirdness. First let's check out the syntax:\n\n```jsx\n//accepts two arguments: a function, and dependency array\nuseEffect(() => {\n    // do stuff\n    return () => {} //function to undo our stuff from above when component unmounts\n}, []) //dependency array of things to watch for changes on\n```\n\nSo you pass `useEffect` a callback function to run that contains your side effects, and then an array of things to watch. If the watched things change, `useEffect` will re-run our callback function. If you need to clean up your side effect on unmount, return a function that contains that code.\n\nLet's look at our pokemon example with hooks and `useEffect`:\n\n```jsx react-live no-edit\nfunction Pokemon() {\n    const [pokemon, setPokemon] = React.useState(null)\n    React.useEffect(() => {\n        fetch('https://pokeapi.co/api/v2/pokemon/gengar/')\n        .then(res => res.json())\n        .then(res => {\n            setPokemon(res)\n        })\n    }, []) // empty array means nothing to watch, so run once and no more\n    const style = {textTransform: 'capitalize'}\n    return (\n        <div>\n        { pokemon\n            ? <>\n                <img src={pokemon.sprites.front_default}\n                    alt={'Image of ' + pokemon.name}/>\n                <p style={style}>Name: {pokemon.name}</p>\n                <p style={style}>\n                    Type: {pokemon.types.map(x => x.type.name).join(', ')}\n                </p>\n            </>\n            : 'Loading...'\n        }\n        </div>\n    )\n}\n```\n\nIf you're staring at that empty dependency array, you've noticed the first `useEffect` quirk. By passing an empty array, we're saying \"only ever do this once\". The React pantheon tells us that on rare occasions that's ok, but most of the time you want something in there. The reason is that usually you want to synchronize with _something_ in your code, not just perform the effect once. For example, what if our pokemon component depended on a route parameter or props, anything that said, \"go get a new pokemon\" without mounting/unmounting?\n\nLet's say our component depended on a prop `pokemonToGet` that was an argument telling it which pokemon to get from the API. Let's also add a tiny form for testing purposes:\n```jsx react-live use-render no-edit\nfunction Pokemon({pokemonToGet}) {\n    const [pokemon, setPokemon] = React.useState(null)\n    React.useEffect(() => {\n        fetch(`https://pokeapi.co/api/v2/pokemon/${pokemonToGet}/`)\n        .then(res => res.json())\n        .then(res => {\n            setPokemon(res)\n        })\n    }, [pokemonToGet]) // get a new pokemon with the pokemonToGet prop changes\n    const style = {textTransform: 'capitalize'}\n    return (\n        <div>\n        { pokemon\n            ? <>\n                <img src={pokemon.sprites.front_default}\n                    alt={'Image of ' + pokemon.name}/>\n                <p style={style}>Name: {pokemon.name}</p>\n                <p style={style}>\n                    Type: {pokemon.types.map(x => x.type.name).join(', ')}\n                </p>\n            </>\n            : 'Loading...'\n        }\n        </div>\n    )\n}\nfunction PokemonForm() {\n    const [inputValue, setInputValue] = React.useState(\"rowlet\")\n    const [pokemonToGet, setPokemonToGet] = React.useState(\"gengar\")\n    function getPokemon() {\n        setPokemonToGet(inputValue.trim().toLowerCase())\n        setInputValue(\"\")\n    }\n    return (\n        <div>\n            <input onChange={(e) => setInputValue(e.target.value)}\n                value={inputValue} type=\"text\"/>\n            <button onClick={getPokemon}>\n                Get Pokemon\n            </button>\n            <Pokemon pokemonToGet={pokemonToGet} />\n        </div>\n    )\n}\nrender(<PokemonForm />)\n```\n\nGreat, now our component fetches a new pokemon based on our prop changes. With classes we would've had to play with `componentDidUpdate` and such to achieve a similar effect.\n\nRyan Florence has a great [tweet](https://twitter.com/ryanflorence/status/1125041041063665666?lang=en) to summarize `useEffect`'s usage:\n\n>The question is not \"when does this effect run\" the question is \"with which state does this effect synchronize with\"\n\n> useEffect(fn) // all state\n\n> useEffect(fn, []) // no state\n\n> useEffect(fn, [these, states])\n\nThat \"all state\" case he mentions where you pass in nothing for dependencies is a weird one. I've personally never found a use for it. We know that the whole component runs with each render, so I'm wondering if there's some weird edge case that requires you to use `useEffect(fn)` without any dependency array. In any case, most of the time you're going to be working with this: `useEffect(fn, [these, states])`.\n\n## UseEffect and Previous State: Where things fall apart\n\nThe mental model so far for `useEffect` seems straight-forward enough: synchronize it with certain state changes of your choosing. The problem is when you need to reference that state in an effect, not just know if it changed.\n\n**You don't get access to current state inside of `useEffect`.**\n\nWe didn't see this in our API call example because we're simply overwriting the previous state.\n\nLet's look at a simple example:\n\n```jsx react-live\nfunction Timer() {\n    const [count, setCount] = React.useState(0)\n\n    React.useEffect(() => {\n        const intervalId = setInterval(() => {\n            setCount(count + 1)\n        }, 1000)\n        return () => clearInterval(intervalId)\n    }, [])\n\n    return (\n        <div>The count is: {count}</div>\n    )\n}\n```\n\nSeems like we did all the right things (even cleaning up our side effect on unmount) but our counter isn't incrementing. Is it a `this` issue? Do we not have access to the `window` object that `setInterval` belongs to?\n\nNo and no. If you added a `console.log` into that interval, you'd see it tick every second.\n\nI'll prove it to you:\n\n```jsx react-live\nfunction Timer() {\n    const [count, setCount] = React.useState(0)\n    const [randomNum, setRandomNum] = React.useState(0)\n\n    React.useEffect(() => {\n        const intervalId = setInterval(() => {\n            setCount(count + 1)\n            setRandomNum(Math.random())\n        }, 1000)\n        return () => clearInterval(intervalId)\n    }, [])\n\n    return (\n        <div>\n            <p>The count is: {count}</p>\n            <p>RandomNum is {randomNum}</p>\n        </div>\n    )\n}\n```\nNotice we get a new random number every second. Our interval code is fine.\n\nWe're able to set new state, but are unable to access current state.\n\nThis is a \"**stale closure**\". I won't get into closures, but just know that because of the implementation of React/hooks, the count variable is always going to be 0 in our interval function. It's an old reference.\n\n**Update 9/7/19**: It turns out, there's a solution for simple examples like above, as pointed out by John Tucker (thanks John!). Much like `setState` in class-based components, `useState` can also accept a callback function that receives the previous state as an argument. The [React Docs](https://reactjs.org/docs/hooks-reference.html#functional-updates) also make note of this.\n\nHere's an example of the quick fix:\n\n```jsx react-live\nfunction Timer() {\n    const [count, setCount] = React.useState(0)\n\n    React.useEffect(() => {\n        const intervalId = setInterval(() => {\n            //let's pass a function instead\n            //the argument is the current state\n            setCount(count => count + 1)\n        }, 1000)\n        return () => clearInterval(intervalId)\n    }, [])\n\n    return (\n        <div>The count is: {count}</div>\n    )\n}\n```\n\nThis still doesn't solve all of our problems, though. If you need to access to the latest state inside `useEffect`, but _not_ update it, you would have to start wrapping your `useEffect` code in `setState` callbacks, and then returning the unchanged state at the end. This could quickly become an absolute mess, particularly if you're working with multiple state values.\n\nAnother possible solution could be to work only with `useReducer`, as that receives previous state, but filling your reducer with side effects also seems very messy, and I wouldn't suggest anyone stop using `useState` entirely.\n\nIn any case, I've fallen into the stale closure trap many, many times when writing hooks. I didn't even know it had a name until I read it in [this talk](https://docs.google.com/presentation/d/1PUvpXMBEDS45rd0wHu6tF3j_8wmGC6cOLtOw2hzU-mw/edit#slide=id.p) by Rich Harris, the man behind [Svelte](https://svelte.dev/).\n\nApparently, I'm not the only one tripping over them in hooks, either:\n\n![Photo of Tweet by Kent Dodds asking about hooks pitfalls and a snarky response of \"stale closures\"](./staleclosures.png)\n\nReact even mentions it in their [docs](https://reactjs.org/docs/hooks-faq.html#why-am-i-seeing-stale-props-or-state-inside-my-function):\n\n>\"Any function inside a component, including event handlers and effects, “sees” the props and state from the render it was created in.\"\n\nI read this prior and it made little sense to me before really digging into the issue. I imagine it could be a bit of a black eye for React, so perhaps they don't wish to call it out too loudly.\n\nDan Abramov, however, describes the problem better in his [blog](https://overreacted.io/a-complete-guide-to-useeffect/) and even provides a solution:\n\n>\"Effects always “see” props and state from the render they were defined in. That helps prevent bugs but in some cases can be annoying. For those cases, you can explicitly maintain some value in a mutable ref.\"\n\nThis was helpful, because it provided a solution in the form of `useRef` (Thanks Dan!), but it left me in the dark as to how it would help avoid the issue (mostly because I didn't understand `useRef`).\n\n## What is a \"ref\", and how do you use one?\n\nSo traditionally, refs were meant to let you directly access an html element. For instance, let's say you needed to focus an input field. You have to bail out of React and use regular JavaScript to call `.focus()`. Hooks actually make this fairly simple:\n\n```jsx react-live\nfunction InputField() {\n    const inputRef = React.useRef()\n    return (\n        <div>\n            <input type=\"text\" ref={inputRef} />\n            <button onClick={() => inputRef.current.focus()}>\n                Click to Focus the input\n            </button>\n        </div>\n    )\n}\n```\n\nGreat! Refs are an easy escape hatch to access native DOM APIs when we need to.\n\n...but how does that help us fix our stale closure counter example?\n\n## Using Refs to avoid Stale Closures\n\nThe [React docs](https://reactjs.org/docs/hooks-faq.html#is-there-something-like-instance-variables) compare refs to \"instance variables\". I didn't know what that meant (thanks [Wikipedia](https://en.wikipedia.org/wiki/Instance_variable)), so I didn't find that helpful.\n\nI managed to wrap my head around refs by thinking about them this way:\n\n**Refs exist outside of the re-render cycle.**\n\nThink of refs as a variable you're setting to the side. When your component re-runs it happily skips over that ref until you call it somewhere with `.current`.\n\nLet's see the fix for our timer example:\n\n```jsx react-live\nfunction Timer() {\n    const [count, setCount] = React.useState(0)\n    const countRef = React.useRef(0)\n\n    React.useEffect(() => {\n        const intervalId = setInterval(() => {\n            countRef.current = countRef.current + 1\n            setCount(countRef.current)\n        }, 1000)\n        return () => clearInterval(intervalId)\n    }, [])\n\n    return (\n        <div>The count is: {count}</div>\n    )\n}\n```\n\nIf we wanted to stop the timer at say, 10, we could easily do so using the ref:\n\n```jsx react-live\nfunction Timer() {\n    const [count, setCount] = React.useState(0)\n    const countRef = React.useRef(0)\n\n    React.useEffect(() => {\n        const intervalId = setInterval(() => {\n            if (countRef.current === 10)\n                return clearInterval(intervalId)\n            countRef.current = countRef.current + 1\n            setCount(countRef.current)\n        }, 1000)\n        return () => clearInterval(intervalId)\n    }, [])\n\n    return (\n        <div>The count is: {count}</div>\n    )\n}\n```\n\nHere's the alternative using the `setState` callback approach, for sake of comparison:\n\n```jsx react-live\nfunction Timer() {\n    const [count, setCount] = React.useState(0)\n\n    React.useEffect(() => {\n        const intervalId = setInterval(() => {\n            setCount(count => {\n                if (count === 10) {\n                    clearInterval(intervalId)\n                    return count\n                }\n                else return count + 1\n            })\n        }, 1000)\n        return () => clearInterval(intervalId)\n    }, [])\n\n    return (\n        <div>The count is: {count}</div>\n    )\n}\n```\n\nI could see this quickly approaching callback hell, so I would caution against using the callback approach if you're doing something more complex.\n\n\n## State Versus Refs\n\nIs it possible to ditch state entirely and just use refs?\n\nYou might be inclined to think you could use refs instead of state for your component and just sidestep all this weird behavior.\n\nYou can't. **Refs aren't reactive.** When you change a ref, it doesn't cause a re-render. (Remember, they exist outside of the re-render cycle).\n\nThis won't work:\n\n\n```jsx react-live\nfunction Timer() {\n    const count = React.useRef(0)\n\n    React.useEffect(() => {\n        const intervalId = setInterval(() => {\n            count.current = count.current + 1\n            //console.log('Ref example count: ' + count.current)\n        }, 1000)\n        return () => clearInterval(intervalId)\n    }, [])\n\n    return (\n        <div>The count is: {count.current}</div>\n    )\n}\n```\n\nThat component is actually counting upwards internally, but it's not causing the HTML to update. You need `useState` for that. (Go ahead and uncomment the `console.log` if you don't believe me)\n\nHere's an example to demonstrate refs vs state:\n\n```jsx react-live use-render\nfunction Counter() {\n  const [count, setCount] = React.useState(0)\n  const countRef = React.useRef(0)\n\n  return (\n    <div>\n      <p>State Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>\n        Increment State Count\n      </button>\n      <p>Ref Count: {countRef.current}</p>\n      <button onClick={() => countRef.current = countRef.current + 1}>\n        Increment Ref Count\n      </button>\n    </div>\n  )\n}\n\nrender(<Counter/>)\n```\n\nYou won't see the ref count change until you trigger a re-render by setting state.\n\n## Parting Thoughts\n\nI love hooks and functional components in React, but the quirks I've outlined have given me pause. I don't like being required to know so much about the inner-workings of React to use it. I think it presents a roadblock for those learning React, and I hope in the future the React team comes up with some better ways to handle these quirks.\n","internal":{"contentFilePath":"/home/lee/dev/side_projects/blog/content/blog/react-use-effect-explained/index.md"}},"next":{"id":"72a3b4a5-4049-5259-a5a2-0b2bf8017b7b","fields":{"slug":"/css-only-menus/"},"frontmatter":{"title":"How to make menus with CSS—no JavaScript or Bootstrap required!"},"body":"\nI think a lot of new developers, myself included, are really excited about CSS until it comes time to start building more modern website features like menus.\n\nI remember building my first site, feeling empowered by CSS to do my own styles, and feeling really proud of myself ...until I needed a navigation menu.\n\n![Pouring coffee into a mug marked \"UGH\". Photo by Nathan Dumlao](./ugh.jpg)\n\nAs soon as I added a few links to my header, I began to run out of room on smaller screens. My site had to look good on mobile, so I was left with a choice:\n\n1. Use Bootstrap menus and include a bunch of JavaScript/jQuery on the page, or\n1. Use fewer links\n\nI've made that choice many times since then, assuming that those were the only options when building navigation menus.\n\n## Creativity through Constraint\n\nIt wasn't until I had to do a coding challenge for a developer job that I had to reckon with the real power of CSS.\n\nI was presented a set of mock-ups of a modern website and told to create the website as close to the provided assets as possible. That's a pretty typical request, except there was one catch: **no JavaScript allowed**.\n\nI thought, _\"No way! There's menus everywhere! How can I pull that off without JS?\"_\n\nThere were **dropdown menus**, **drawers**, and even a Bootstrap-esque **mobile hamburger menu** on one of the mocks.\n\nBeing the intrepid developer that I am, I saw this as a fun challenge. I hopped on Codepen and began searching for CSS-only versions of these common UI components.\n\nAfter a little digging, I found examples for all of them! While there were some tricks involved that I would have never thought of, the tricks themselves were simple.\n\nI took those new tricks and used them to finish the coding challenge. And yes, I got the job!\n\nI had always been told that CSS was super powerful, but I don't think I believed it until that point.\n\nSo without further adieu, here's how I managed to recreate all of those menus with CSS alone.\n\n## The Classic Dropdown Menu\n\nThe first menu I want to talk about is the dropdown menu. You've probably seen this on any e-commerce site or anything with lots of categories and navigation. There's a header up top with a list of categories, and when you mouse over one, a new menu appears with more related items.\n\nHere's an example:\n```css css-live\n.dropdown__header * {\n  padding: 0;\n  margin: 0;\n}\n.dropdown__header {\n  display: flex;\n  align-items: center;\n  background: lightblue;\n}\n\n.dropdown__header strong {\n  margin-left: 5px;\n  margin-right: auto;\n  font-size: 1.6rem;\n}\n\n.dropdown__header .dropdown__categories,\n.dropdown__header .dropdown__menu {\n  display: flex;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.dropdown__header li {\n  padding: 10px;\n  position: relative;\n}\n\n.dropdown__header li:hover {\n  background: #d2f2fc;\n}\n\n.dropdown__header .dropdown__category .dropdown__menu {\n  display: none;\n  position: absolute;\n  background: #ebfaff;\n  width: 200px;\n  top: 50px;\n  right: 0;\n}\n\n.dropdown__header .dropdown__category:hover .dropdown__menu {\n  display: block;\n}\n```\n\n```html html-live\n<header class=\"dropdown__header\">\n  <strong>Logo</strong>\n  <ul class=\"dropdown__categories\">\n    <li class=\"dropdown__category\">\n      <span>Cat 1</span>\n      <ul class=\"dropdown__menu\">\n        <li>Cat 1 Thing</li>\n        <li>Cat 1 Thing</li>\n        <li>Cat 1 Thing</li>\n        <li>Cat 1 Thing</li>\n      </ul>\n    </li>\n    <li class=\"dropdown__category\">\n      <span>Cat 2</span>\n      <ul class=\"dropdown__menu\">\n        <li>Cat 2 Thing</li>\n        <li>Cat 2 Thing</li>\n        <li>Cat 2 Thing</li>\n        <li>Cat 2 Thing</li>\n      </ul>\n    </li>\n  </ul>\n</header>\n<br>\n<h3>CSS Only Dropdown!</h3>\n<p>Hover over the Categories above</p>\n<p>Pretty cool, right?</p>\n```\n\n### What makes this work?\n\nThere's three main concepts here that make this possible: **Showing/Hiding with Psuedoselectors**, **absolute positioning**, and **mindful HTML structure**.\n\n#### Showing/Hiding with Pseudoselectors\n\nI think most people are comfortable showing/hiding things with `display: none` and `display: block`. The real trick here is the selectors.\n\nWe're targetting `.dropdown__menu`, but notice the nesting structure. We're looking for a `.dropdown__menu` class that's within a `.dropdown__category` class. Then we can apply the `:hover` pseudoselector to the parent, which means we're targetting the menu based on a hover over the parent.\n\n```css\n.dropdown__header .dropdown__category .dropdown__menu {\n  display: none;\n}\n\n.dropdown__header .dropdown__category:hover .dropdown__menu {\n  display: block;\n}\n```\n\n#### Mindful HTML Structure\n\nAre you wondering why our menu stays open even when you move your mouse into the menu?\n\nGoing along with our nesting explanation above, note that our `.dropdown__menu` is contained within `.dropdown__category`:\n\n```html\n<li class=\"dropdown__category\">\n  <span>Cat 1</span>\n  <ul class=\"dropdown__menu\">\n    <li>Cat 1 Thing</li>\n    <li>Cat 1 Thing</li>\n    <li>Cat 1 Thing</li>\n    <li>Cat 1 Thing</li>\n  </ul>\n</li>\n```\n\nThis means that although we're no longer over the words \"Cat 1\", the mouse is still within the `.dropdown__category` list item, keeping the `:hover` selector trigger active.\n\n**Note**: The menu and category elements must be adjacent to each other so that your mouse stays within one or the other--you can't position the menu off by itself somewhere and be able to mouse into it. More on that when we get to positioning.\n\n#### Absolute Positioning\n\nWe position the hovered menu next to the category in the header using `position: absolute;`.\n\nW3 Schools has a [great breakdown](https://www.w3schools.com/css/css_positioning.asp) of CSS positioning, but here's the short version:\n\nWhen you set positioning, items can be moved around with `top`, `bottom`, `left`, and `right` options.\n\n* **Static**: The default. The element behaves normally, and is unaffected by top/bottom/left/right.\n* **Fixed**: The element is positioned relative to the viewport. Eg: `top: 0;` would be the top of the viewer's screen.\n* **Relative**: The element is positioned based on where it would be normally. So `top: 0` wouldn't move it at all, and `top: 10px` would push it down 10 pixels.\n* **Sticky**: This is a newer, trickier positioning. The element stays where it is, but when the user scrolls the page, before the element moves out of view, it will still stick to whatever top/bottom/left/right position is set.\n\nAnd lastly, there's **Absolute** positioning. This is the most complicated. The behavior depends on whether this element is within an element that has some kind of positioning set. **If it has a positioned ancestor, it positions relative to that ancestor element. If not, it is positioned relative to the whole page.**\n\nIn the case of our dropdown menus, we make the `li` tag that contains the menu `relative`. Then within it we can use `position: absolute;` to position the expanded menu around our category title.\n\n```css\n.dropdown__header li {\n  position: relative;\n}\n\n.dropdown__header .dropdown__category .dropdown__menu {\n  position: absolute;\n  top: 50px;\n  right: 0;\n}\n```\n\nHere we right-align the menu, and bump it down just far enough so that it's at the bottom of \"Cat 1\" under our mouse.\n\n## Nested Dropdown Menus\n\nUsing the same techniques, we can create a more complicated dropdown menu:\n\n```css css-live\n.nested-dropdown__header * {\n  padding: 0;\n  margin: 0;\n}\n.nested-dropdown__header {\n  display: flex;\n  align-items: center;\n  background: lightblue;\n}\n\n.nested-dropdown__header strong {\n  margin-left: 5px;\n  margin-right: auto;\n  font-size: 1.6rem;\n}\n\n.nested-dropdown__header ul {\n  display: flex;\n  list-style: none;\n  padding: 0;\n  margin: 0;\n}\n\n.nested-dropdown__header li {\n  padding: 10px;\n  position: relative;\n}\n\n.nested-dropdown__header li:hover {\n  background: #d2f2fc;\n}\n\n.nested-dropdown__header .nested-dropdown__menu,\n.nested-dropdown__header .nested-dropdown__submenu {\n  display: none;\n  position: absolute;\n  background: #ebfaff;\n  width: 150px;\n  top: 50px;\n  right: 0;\n}\n\n.nested-dropdown__header .nested-dropdown__category:hover .nested-dropdown__menu,\n.nested-dropdown__header .nested-dropdown__subcategory:hover .nested-dropdown__submenu {\n  display: block;\n}\n\n.nested-dropdown__header .nested-dropdown__submenu {\n  top: 0;\n  right: 100%;\n}\n```\n\n```html html-live\n<header class=\"nested-dropdown__header\">\n  <strong>Logo</strong>\n  <ul class=\"nested-dropdown__categories\">\n    <li class=\"nested-dropdown__category\">\n      <span>Cat 1</span>\n      <ul class=\"nested-dropdown__menu\">\n        <li class=\"nested-dropdown__subcategory\">\n          <span>Sub Cat 1</span>\n          <ul class=\"nested-dropdown__submenu\">\n            <li>Sub Cat 1 Thing</li>\n            <li>Sub Cat 1 Thing</li>\n            <li>Sub Cat 1 Thing</li>\n            <li>Sub Cat 1 Thing</li>\n          </ul>\n        </li>\n        <li class=\"nested-dropdown__subcategory\">\n          <span>Sub Cat 2</span>\n          <ul class=\"nested-dropdown__submenu\">\n            <li>Sub Cat 2 Thing</li>\n            <li>Sub Cat 2 Thing</li>\n            <li>Sub Cat 2 Thing</li>\n          </ul>\n        </li>\n        <li>Cat 1 Thing</li>\n        <li>Cat 1 Thing</li>\n      </ul>\n    </li>\n  </ul>\n</header>\n<br>\n<h3>CSS Only NESTED Dropdown!</h3>\n<p>Hover over 'Cat 1' above,</p>\n<p>Then check out the Sub Categories!</p>\n```\n\nThere's only two caveats to this nested menu.\n\nThe first is that it doesn't work well on mobile devices. This type of menu requires a lot of real-estate and hovers don't translate to touchscreens very well. This isn't a fault of CSS, though. Most sites will switch to a different style of menu on smaller devices, regardless of CSS vs JS.\n\nThe second is that if your user wants to jump from a menu to a nested menu, she may take the shortest path and unintentionally move her mouse cursor out of the current element. Deeply nested menus are a little perilous for the user, so use with caution.\n\n## Content Drawers\n\nCreating drawers with CSS alone seemed impossible. Hover effects don't work, because when you open a drawer, you expect it to stay open. However, I learned that it _is_ possible with some very clever uses of HTML input elements and CSS selectors.\n\nThis example has quite a bit of CSS, but don't fret, I promise to explain the important bits:\n\n```css css-live\n.drawer {\n  position: relative;\n  box-sizing: border-box;\n  width: 300px;\n}\n.drawer input {\n  width: 100%;\n  height: 60px;\n  position: absolute;\n  opacity: 0;\n  top: 0;\n  left: 0;\n  margin: 0;\n  z-index: 3;\n  cursor: pointer;\n}\n.drawer__name {\n  display: flex;\n  justify-content: space-between;\n  border: 1px solid black;\n  padding: 10px;\n  background: lightblue;\n}\n.drawer__content {\n  border: 1px solid black;\n  box-sizing: border-box;\n  width: 100%;\n  margin: 0;\n  height: 0;\n  opacity: 0;\n  pointer-events: none;\n  list-style: none;\n  transition: padding 0.2s;\n}\n.drawer input:checked ~ .drawer__content {\n  height: 100%;\n  opacity: 1;\n  pointer-events: initial;\n  padding: 10px 0;\n}\n.drawer__arrow {\n  font-weight: 900;\n  font-size: 1.2rem;\n  transition: transform 0.2s;\n}\n.drawer input:checked ~ .drawer__name > .drawer__arrow {\n  transform: rotateZ(90deg);\n}\n.drawer__content li {\n  padding: 10px;\n  cursor: pointer;\n}\n.drawer__content li:hover {\n  color: rebeccapurple;\n  text-decoration: underline;\n}\n```\n```html html-live\n<div class=\"drawer\">\n  <input type=\"checkbox\">\n  <span class=\"drawer__name\">\n    <span><strong>Bananas</strong></span>\n    <span class=\"drawer__arrow\">></span>\n  </span>\n  <ul class=\"drawer__content\">\n    <li>Bruised</li>\n    <li>Green</li>\n    <li>Perfect</li>\n  </ul>\n</div>\n<div class=\"drawer\">\n  <input type=\"checkbox\">\n  <span class=\"drawer__name\">\n    <span><strong>Apples</strong></span>\n    <span class=\"drawer__arrow\">></span>\n  </span>\n  <ul class=\"drawer__content\">\n    <li>Mealy</li>\n    <li>Crisp</li>\n    <li>Green</li>\n  </ul>\n</div>\n<div class=\"drawer\">\n  <input type=\"checkbox\">\n  <span class=\"drawer__name\">\n    <span><strong>Oranges</strong></span>\n    <span class=\"drawer__arrow\">></span>\n  </span>\n  <ul class=\"drawer__content\">\n    <li>Bitter</li>\n    <li>Sour</li>\n    <li>Sweet</li>\n  </ul>\n</div>\n```\n\nTa-da! ✨ Pure CSS drawers!\n\nIt seems like a lot of code is required to make this happen, but there's just a few key pieces to this puzzle that make it possible.\n\n### What makes this work?\n\nThe main trick here really did blow my mind. The secret is **HTML checkbox elements**.\n\n**Note:** I would have never thought of this in a million years. When I saw an example of this on Codepen I experienced the same feelings I had when seeing an awesome magic trick explained; I felt amazement of the ingenuity involved, and also anger at being duped by such a simple trick that I should have been able to figure out for myself.\n\nIf we position the checkbox over the drawer and stretch it to the same size as the drawer, then target siblings on a `:checked` state, we can eliminate the need for JavaScript to trigger the open/close events. The CSS sibling selector is `~`, meaning target any neighbor elements coming after this element.\n\nIt's important to note that the **checkbox must come first in the HTML**. You can select sibling/neighbor elements that come after, but not before. We also use `~` and not `+` because `+` targets only the first adjacent sibling element, whereas `~` will give you any following sibling.\n\n```css css-live no-code\n.ex2-drawer {\n  position: relative;\n  box-sizing: border-box;\n  width: 300px;\n}\n.ex2-drawer input {\n  width: 100%;\n  height: 60px;\n  outline: 2px solid red;\n  position: absolute;\n  /* opacity: 0; */\n  top: 0;\n  left: 0;\n  margin: 0;\n  z-index: 3;\n  cursor: pointer;\n}\n.ex2-drawer__name {\n  display: flex;\n  justify-content: space-between;\n  border: 1px solid black;\n  padding: 10px;\n  background: lightblue;\n}\n.ex2-drawer__content {\n  border: 1px solid black;\n  box-sizing: border-box;\n  width: 100%;\n  margin: 0;\n  height: 0;\n  opacity: 0;\n  pointer-events: none;\n  list-style: none;\n  transition: padding 0.2s;\n}\n.ex2-drawer input:checked ~ .ex2-drawer__content {\n  height: 100%;\n  opacity: 1;\n  pointer-events: initial;\n  padding: 10px 0;\n}\n.ex2-drawer__arrow {\n  font-weight: 900;\n  font-size: 1.2rem;\n  transition: transform 0.2s;\n}\n.ex2-drawer input:checked ~ .ex2-drawer__name > .ex2-drawer__arrow {\n  transform: rotateZ(90deg);\n}\n.ex2-drawer__content li {\n  padding: 10px;\n  cursor: pointer;\n}\n.ex2-drawer__content li:hover {\n  color: rebeccapurple;\n  text-decoration: underline;\n}\n```\n```html html-live no-code\n<div class=\"ex2-drawer\">\n  <input type=\"checkbox\">\n  <span class=\"ex2-drawer__name\">\n    <span><strong>Bananas</strong></span>\n    <span class=\"ex2-drawer__arrow\">></span>\n  </span>\n  <ul class=\"ex2-drawer__content\">\n    <li>Bruised</li>\n    <li>Green</li>\n    <li>Perfect</li>\n  </ul>\n</div>\n<div class=\"ex2-drawer\">\n  <input type=\"checkbox\">\n  <span class=\"ex2-drawer__name\">\n    <span><strong>Apples</strong></span>\n    <span class=\"ex2-drawer__arrow\">></span>\n  </span>\n  <ul class=\"ex2-drawer__content\">\n    <li>Mealy</li>\n    <li>Crisp</li>\n    <li>Green</li>\n  </ul>\n</div>\n<div class=\"ex2-drawer\">\n  <input type=\"checkbox\">\n  <span class=\"ex2-drawer__name\">\n    <span><strong>Oranges</strong></span>\n    <span class=\"ex2-drawer__arrow\">></span>\n  </span>\n  <ul class=\"ex2-drawer__content\">\n    <li>Bitter</li>\n    <li>Sour</li>\n    <li>Sweet</li>\n  </ul>\n</div>\n```\n\nThe other important piece to this puzzle is the transition. Notice we didn't use `display` here to show and hide the drawer. If you do, you won't be able to use CSS transitions to animate. **You can't animate an element that's hidden with `display: none`**\n\nInstead, we use a combo of `height`, `padding`, `opacity`, and `pointer-events`. (That seems like a lot, but hear me out).\n\nHere's the main code that makes this possible for reference:\n```css\n.drawer {\n  position: relative;\n}\n.drawer input {\n  width: 100%;\n  height: 60px;\n  position: absolute;\n  opacity: 0;\n  top: 0;\n  left: 0;\n  z-index: 3;\n  cursor: pointer;\n}\n.drawer__content {\n  height: 0;\n  opacity: 0;\n  pointer-events: none;\n  transition: padding 0.2s;\n}\n.drawer input:checked ~ .drawer__content {\n  height: 100%;\n  opacity: 1;\n  pointer-events: initial;\n  padding: 10px 0;\n}\n```\n```html\n<div class=\"drawer\">\n  <input type=\"checkbox\">\n  <span class=\"drawer__name\">\n    <span><strong>Oranges</strong></span>\n    <span class=\"drawer__arrow\">></span>\n  </span>\n  <ul class=\"drawer__content\">\n    <li>Bitter</li>\n    <li>Sour</li>\n    <li>Sweet</li>\n  </ul>\n</div>\n```\n\nFirst we squash the `.drawer__content` with `height: 0`, and hide it with `opacity: 0`. However, because it's still on the page, the user would be able to click the things within, even though the content isn't visible. The solution is to disable mouse interaction with `pointer-events: none`. This allows us to animate the content while not letting the use see or interact with it.\n\nFinally, we use `padding` as our animation. Animating the `height` causes some weird behavior, but animating the padding allows some for some subtle animation while keeping the drawer itself very responsive.\n\n**Note:** It's possible to make drawers with just HTML alone using the `details` element. You lose out on the ability to animate with CSS, though.\n\nHere's a quick example. None of the CSS is necessary for the drawer behavior:\n\n```css css-live\ndetails {\n  background: rebeccapurple;\n  color: #ddd;\n  width: 300px;\n  border-radius: 4px;\n  margin-bottom: 5px;\n}\nsummary {\n  padding: 10px;\n}\nsummary:focus {\n  outline: none;\n}\ndetails ul {\n  background: #ddd;\n  margin: 0;\n  color: black;\n  padding: 10px;\n  border-radius: 0 0 4px 4px;\n}\n\ndetails li {\n  margin-left: 30px;\n  margin-top: 10px;\n}\n```\n```html html-live\n<details open>\n  <summary>Drawer 1</summary>\n  <ul>\n    <li>Thing 1</li>\n    <li>Thing 2</li>\n    <li>Thing 3</li>\n    <li>Thing 4</li>\n  </ul>\n</details>\n<details>\n  <summary>Drawer 2</summary>\n  <ul>\n    <li>Thing 1</li>\n    <li>Thing 2</li>\n    <li>Thing 3</li>\n    <li>Thing 4</li>\n  </ul>\n</details>\n```\n## CSS Only Hamburger Menus\n\nNow for the coup de grâce, CSS-only Hamburger menus!\n\nWhat's a hamburger menu? It gets its name from the three stacked dashes that indicate \"hey this is a menu\". I guess someone was awful hungry for three lines to look like a hamburger, but I digress.\n\nYou may have some ideas on how to pull this off in your head after seeing the previous examples. Let's take a look (Warning, incoming a ton of CSS):\n\n```css css-live\n.hamburger-menu__wrapper {\n  min-height: 400px;\n  position: relative;\n  text-align: center;\n}\n.hamburger-menu {\n  height: 100%;\n  width: 300px;\n  position: absolute;\n  top: 0;\n  left: 0;\n}\n.hamburger-menu__button {\n  width: 40px;\n  height: 40px;\n  border: 2px solid #777;\n  border-radius: 5px;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  position: relative;\n  z-index: 3;\n}\n\n.hamburger-menu__button span {\n  line-height: 8px;\n  text-align: center;\n  font-size: 1.6rem;\n  font-weight: 400;\n}\n\n.hamburger-menu__button span:last-child {\n  padding-bottom: 5px;\n}\n.hamburger-menu__wrapper {\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n}\n.hamburger-menu__wrapper input[type='checkbox'] {\n  width: 40px;\n  height: 40px;\n  outline: 3px solid red;\n  opacity: 0;\n  position: absolute;\n  top: 6px;\n  left: 6px;\n  z-index: 4;\n  cursor: pointer;\n}\n\n.hamburger-menu__wrapper input:checked ~ .hamburger-menu__button {\n  background: #d2f2fc;\n}\n\n.hamburger-menu__wrapper input:checked ~ .hamburger-menu__slider {\n  transform: none;\n}\n\n.hamburger-menu__slider {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 100%;\n  background-color: lightblue;\n  z-index: 2;\n  transform: translateX(-310px);\n  transition: transform 0.3s;\n  text-align: left;\n}\n\n.hamburger-menu__item {\n  padding: 10px 0 10px 10px;\n}\n\n.hamburger-menu__item:hover {\n  background-color: #d2f2fc;\n}\n\n.hamburger-menu__item:first-of-type {\n  margin-top: 60px;\n}\n```\n\n```html html-live\n<div class=\"hamburger-menu__wrapper\">\n  <div class=\"hamburger-menu\">\n    <div class=\"hamburger-menu__wrapper\">\n      <input type=\"checkbox\" />\n      <div class=\"hamburger-menu__button\">\n        <span>&mdash;</span>\n        <span>&mdash;</span>\n        <span>&mdash;</span>\n      </div>\n      <div class=\"hamburger-menu__slider\">\n        <div class=\"hamburger-menu__item\">Thing 1</div>\n        <div class=\"hamburger-menu__item\">Thing 2</div>\n        <div class=\"hamburger-menu__item\">Thing 3</div>\n        <div class=\"hamburger-menu__item\">Thing 4</div>\n      </div>\n    </div>\n  </div>\n  <h2>Hamburger!!</h2>\n  <p>Click the Button to toggle the menu</p>\n</div>\n```\n\nTake ***that***, bootstrap. 🤠\n\n### What makes it work?\n\nA lot of the CSS above is for creating that silly hamburger style button. I literally stacked dashes and put a border around them, but you can use an icon if you like.\n\nAs for the menu, it uses **absolute positioning**, the **input checkbox trick**, as well as a new trick, which is using **transform** to slide the drawer in and out.\n\nHere's the code that makes the menu slide:\n```css\n.hamburger-menu__wrapper {\n  position: relative;\n  height: 100%;\n  overflow: hidden;\n}\n\n.hamburger-menu__wrapper input:checked ~ .hamburger-menu__slider {\n  transform: none;\n}\n\n.hamburger-menu__slider {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 300px;\n  height: 100%;\n  z-index: 2;\n  transform: translateX(-310px);\n  transition: transform 0.3s;\n}\n```\n\nWe style the menu to sit on top of the page, then add in `transform: translateX(-310px)` to pull the menu to the left so it's no longer visible. When the `input` is checked, we remove that `transform` and the transition animates the drawer sliding into view.\n\nThere's a ton of other neat things you can do with the `transform` property. We used it above on our drawers to turn our arrow to point downward when the drawer is open, for example.\n\nWe also use `overflow: hidden` on the wrapper to make sure our menu isn't visible when the menu is closed.\n\n**Note:** We also use `z-index` here to make sure things stack on top of each other. Absolute positioning breaks items out of normal HTML flow, so making sure the menu is on top is crucial. Even more critical, we apply a higher z-index to the checkbox to make sure the user can always open and close the menu. We applied `z-index` to our drawer checkboxes as well above.\n\n## But about JavaScript?\n\nSo yes, the point of this click-baity article title was that these things are possible _without_ JavaScript. But does that make sense?\n\nCSS is incredibly performant in general compared to using JavaScript. So it's a good rule of thumb to use CSS instead of JS for most things.\n\nThat said, some of these examples could be improved with JavaScript. Certainly toggling open/closed states would be much simpler using JS. Also, our hamburger example could benefit from being able to click outside of the menu to close the drawer. For the drawers, you might want to only have one of the drawers open above at a time. And for the dropdown menus you might want to slow the closing of the menus when the mouse cursor moves outside of the menu.\n\nIf you're already using an SPA like React, you may as well use a touch of JavaScript with your CSS to build the menus.\n\nThe point here is that **for a simple site, you don't need to reach for CSS frameworks or JS frameworks.**\n\n## Parting Thoughts\n\nCSS is powerful, and we could all use more excuses to practice and learn more and do more with it. HTML deserves a shout-out here as well. You can build a lot with HTML and CSS alone. Certainly more than I thought was possible when I started out.\n\nJavaScript may rule the world, but CSS and HTML deserve your attention as a front-end developer as well.","internal":{"contentFilePath":"/home/lee/dev/side_projects/blog/content/blog/css-only-menus/index.md"}},"frontmatter":{"title":"Bridging the Gap between React's useState, useReducer, and Redux","date":"2019-09-12T12:00:00-0400"}}},"staticQueryHashes":["2836739900","4250957540"],"slicesMap":{}}