{"componentChunkName":"component---src-templates-blog-post-js-content-file-path-home-lee-dev-side-projects-blog-content-blog-how-to-debounce-index-md","path":"/how-to-debounce/","result":{"data":{"site":{"siteMetadata":{"title":"Strings and Things","author":"Lee Warrick","siteUrl":"https://leewarrick.com/blog"}},"mdx":{"id":"b412c488-45ca-51b9-9f6d-77f1de52163e","excerpt":"Have you ever heard the story of the QWERTY layout on a keyboard? The popular legend is that it was too easy to type if the letters were arranged alphabetically, and this caused‚Ä¶","frontmatter":{"title":"What are debounce and throttle functions, and how do you write them in JavaScript and React?","date":"October 17, 2019"},"body":"![Photo of Typewriter by Pereanu Sebastian](./typewriter.jpg)\n\nHave you ever heard the story of the QWERTY layout on a keyboard? The [popular legend](https://en.wikipedia.org/wiki/Typewriter#QWERTY) is that it was too easy to type if the letters were arranged alphabetically, and this caused mechanical typewriters to jam. The most common letters were too close together, supposedly. So to fix this, the QWERTY layout was invented, to _slow down the typist_.\n\nThis Dilbertian engineering idea is eerily similar to what a debounce function does.\n\n## What is a debounce?\n\nA debounce function is meant to slow down something in your application, typically a function call. The best way to wrap your head around this is by example.\n\nConsider this: you have a search input on your site somewhere, and _as the user types_, you want to go fetch some search results to try and match what the user is looking for before they finish typing.\n\n_Piece of cake!_, you think. With React, you can attach your API call to your input's `onChange` event like so:\n\n```jsx react-live\nfunction SearchForm() {\n  const [inputVal, setInputVal] = React.useState(\"\")\n  const [callCount, setCallCount] = React.useState(0)\n\n  function handleChange(e) {\n    setInputVal(e.target.value)\n    // let's say this was an API call\n    // to add auto-complete data\n    setCallCount(callCount + 1)\n  }\n\n  return (\n    <div>\n      <h2>Type in this Box ‚¨áÔ∏è</h2>\n      <input onChange={handleChange} value={inputVal}/>\n      <p>Current Data: {inputVal}</p>\n      <p>Calls Done: {callCount}</p>\n    </div>\n  )\n}\n```\n\nNotice that as you type in the search box, if your API function is attached to your input's `onChange` event, you'll make an API call _every time the user presses a key_ üò±. If you couple this with the small delay it takes to make an API call, you can imagine the traffic jam that this would cause as you have multiple API calls being made and flooding back in.\n\nThis isn't what we imagined when we first cooked up this auto-populating search box scheme. What we _really_ want to do is to make our API call when the user pauses or stops typing.\n\nThis is the purpose of a **debounce** function, to limit the amount of calls that can happen in a given amount of time.\n\n## How to debounce a function in JavaScript\n\nSo we need to fire fewer API calls, but how do we do it?\n\nBefore we jump into React, let's give this a shot with regular JavaScript. Let's put our fake API call in its own function, then wrap it in our debounce function.\n\n```js js-live\nlet callCount = 0\n\n// this is just a promise that resolves after 300ms\n// and console logs a counter\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      callCount++\n      console.log(\"Calls Made:\" + callCount)\n      resolve()\n    }, 300)\n  })\n}\n\nfakeAPICall() // 1\nfakeAPICall() // 2\nfakeAPICall() // 3\n\nfunction debounce(callback) {\n    // each call to debounce creates a new timeoutId\n    let timeoutId\n    return function() {\n      // this inner function keeps a reference to\n      // timeoutId from the function outside of it\n      clearTimeout(timeoutId)\n      timeoutId = setTimeout(callback, 800)\n    }\n}\n\n// wraps the fakeAPICall function and returns\n// a function that calls fakeAPICall\nconst debouncedFakeApiCall = debounce(fakeAPICall)\n\n// all these calls cancel each other\n// Until the last call finally happens after 800 ms\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall() // 4\n```\n\nSuccess!\n\nWithout a debounce, we get 3 calls, but with a debounce, we only fire an API call **on the last function call**.\n\n### How it works\n\nThe most basic, critical piece of this debounce function is to delay the actual API call, then as more calls come in, cancel and reset the delay for the API call. We do this with `setTimeout` and `clearTimeout` in the JavaScript above.\n\nIf you noticed the debounce function taking a function and returning a another function, that is an example of a closure in JavaScript. When we debounce a function, we pass our original function in, and wrap it in another function that delays calls to the original. In this way our debounce function is reusable throughout our program. We could debounce as many different functions as we want, **because each one has its own `timeoutId` variable**.\n\n## How to write a debounce function in React\n\nReact allows us to encapsulate logic in components, so we can skip the fancy JavaScript closures and just use our component to write a debounce function.\n\nLet's take a look:\n\n```jsx react-live use-render\n// just an async helper\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(resolve, 300)\n  })\n}\n\nfunction SearchForm() {\n  const [inputVal, setInputVal] = React.useState(\"\")\n  const [query, setQuery] = React.useState(\"\")\n  const inputRef = React.useRef(\"\")\n  const [callCount, setCallCount] = React.useState(0)\n  const timeoutId = React.useRef()\n\n  function handleChange(e) {\n    setInputVal(e.target.value)\n    // mimic the value so we can access\n    // the latest value in our API call\n    inputRef.current = e.target.value\n  }\n\n  React.useEffect(() => {\n    // if the user keeps typing, stop the API call!\n    clearTimeout(timeoutId.current)\n    // don't make an API call with no data\n    if (!inputVal.trim()) return\n    // capture the timeoutId so we can\n    // stop the call if the user keeps typing\n    timeoutId.current = setTimeout(() => {\n      // grab our query, but store it in state so\n      // I can show it to you below in the example üòÑ\n      setQuery(inputRef.current)\n      fakeAPICall()\n      // here we pass a callback so we get the current callCount value\n      // from the useState hook's setter function\n      // we use a Ref for timeoutId to avoid this same problem\n      .then(() => setCallCount(callCount => callCount + 1))\n    }, 800)\n  }, [inputVal])\n\n  return (\n    <div>\n      <h2>Type in this Box ‚¨áÔ∏è</h2>\n      <input onChange={handleChange} value={inputVal}/>\n      <p>Current Data: {inputVal}</p>\n      <p>Query Sent: {query}</p>\n      <p>Calls Done: {callCount}</p>\n    </div>\n  )\n}\n\nrender(SearchForm)\n```\nNow as we type, the component won't actually make any API calls until the typing stops.\n\nThe only difference here is that instead of writing a closure, we're using a React Ref for our `timeoutId`. Refs are React's version of instance variables, so each SearchForm component that we make should get its own `timeoutId`. If you want to learn more about Refs and `useEffect`, [I wrote another post on that topic](https://leewarrick.com/blog/react-use-effect-explained/).\n\n## What is a throttle?\n\nThis might not be exactly what you imagined when you envisioned this functionality. For example, as you type into Google search, you still get autocomplete suggestions as you type, even if you haven't stopped typing.\n\nSo while our previous examples will ensure we do the _fewest_ API calls possible, we may want to tweak our solution to **make an API call every so often as the user types**. This would be a **throttle** function.\n\n## How to write a throttle in JavaScript\n\nLet's tweak our JavaScript debounce implementation so that we only make our API call every 800ms.\n\n```js js-live\nlet callCount = 0\n\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      callCount++\n      console.log(\"Calls Made:\" + callCount)\n      resolve()\n    }, 300)\n  })\n}\n\nfunction throttle(cb) {\n    let makingCall\n    return function() {\n      // if I'm in progress of making an API call,\n      // don't trigger another one\n      if (makingCall) return\n      // set up API call to fire\n      makingCall = true\n      // give the user some time to type by delaying the actual call\n      setTimeout(() => {\n        makingCall = false\n        cb()\n      }, 800)\n    }\n}\n\nconst throttledFakeApiCall = throttle(fakeAPICall)\n\n// imagine the user starting and stopping typing\n// we'll only make a call every 800ms\nthrottledFakeApiCall() // 1\nthrottledFakeApiCall()\nthrottledFakeApiCall()\nsetTimeout(() => {\n  throttledFakeApiCall()\n  throttledFakeApiCall()\n}, 600)\nsetTimeout(() => {\n  throttledFakeApiCall() // 2\n  throttledFakeApiCall()\n}, 1200)\nsetTimeout(() => {\n  throttledFakeApiCall()\n  throttledFakeApiCall()\n}, 1800)\nsetTimeout(() => {\n  throttledFakeApiCall() // 3\n  throttledFakeApiCall()\n}, 2400)\n\n```\n\nNow as our throttle function fires, we are limiting our calls to happen every 800ms.\n\n### How it works\n\nThis new version uses a simple `true`/`false` value to determine if we should trigger more calls instead of clearing the timeout and cancelling previous calls. Now the first call to the throttled function tees up the call, and the subsequent calls are ignored until the API call is complete.\n\n## How to write a throttle in React\n\nLet's apply this same functionality to our previous React example.\n\n```jsx react-live use-render\n// just an async helper\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(resolve, 300)\n  })\n}\n\nfunction SearchForm() {\n  const [inputVal, setInputVal] = React.useState(\"\")\n  const [query, setQuery] = React.useState(\"\")\n  const inputRef = React.useRef(\"\")\n  const [callCount, setCallCount] = React.useState(0)\n  const makingCall = React.useRef(false)\n\n  function handleChange(e) {\n    setInputVal(e.target.value)\n    // mimic the value so we can access\n    // the latest value in our API call\n    inputRef.current = e.target.value\n  }\n\n  React.useEffect(() => {\n    // if there's no value or we've already triggered a call\n    // prevent further calls\n    if (!inputVal.trim() || makingCall.current) return\n    makingCall.current = true\n    setTimeout(() => {\n      makingCall.current = false\n      // again, this setQuery is just so I can\n      // render the query below.\n      // if this API call were real, we'd probably\n      // pass the query into the API call function\n      setQuery(inputRef.current)\n      fakeAPICall()\n      .then(() => {\n        setCallCount(callCount => callCount + 1)\n      })\n    }, 800)\n  }, [inputVal])\n\n  return (\n    <div>\n      <h2>Type in this Box ‚¨áÔ∏è</h2>\n      <input onChange={handleChange} value={inputVal}/>\n      <p>Current Data: {inputVal}</p>\n      <p>Query Sent: {query}</p>\n      <p>Calls Done: {callCount}</p>\n    </div>\n  )\n}\n\nrender(SearchForm)\n```\n\nSuccess! Now as the user types, every 800ms we make a call for an autocomplete suggestion. This means **more API calls, but better user experience**, at least in the case of our search autocomplete example.\n\n## Parting Thoughts\n\nSo there you have it: throttling and debounce functions in JS and React.\n\nBut would you ever implement this yourself in real life?\n\nSure! If you just needed simple functionality like this, you could absolutely manage your own debounce logic/helpers in your app. However, there's no shame in pulling in Lodash and using the [debounce](https://lodash.com/docs/4.17.15#debounce) or [throttle](https://lodash.com/docs/4.17.15#throttle) functions that they've implemented.\n\nI find it fun to try and implement my own solutions, and I think it's worth the mental gymnastics to give this stuff a shot in your own code every once in a while. But don't be fooled, nobody will judge you if you reach for a third-party solution!"}},"pageContext":{"slug":"/how-to-debounce/","previous":{"id":"f6d9912f-db42-550a-80df-5956b0ba0fe1","fields":{"slug":"/angular-vs-react-vs-vue/"},"frontmatter":{"title":"Front-end Fisticuffs: Angular vs React vs Vue in 2019"},"body":"\n![Cowboy riding horse and kicking up dirt by Lee Pigott](./cowboy.jpg)\n\nBeing a front-end developer is a bit like being a cowboy in a rodeo. As a developer, you'll find yourself wrangling a new framework over and over because of the speed at which the front-end landscape evolves. Sure, learning comes with the territory as a developer, but front-end development in particular is becoming quite the skillset to maintain.\n\nThe fact is, you're likely going to need to know at least one if you're going to become a web developer. Before we talk about choosing one to spend your time on, let's first highlight the problems they solve.\n\n## Why use a framework?\n\nThree weeks into a boot camp, I was amazed with the things I could build with HTML/CSS/JS, including [a dice-roll based RPG for the browser.](https://leewarrick.com/rpg)\n\nI've often wanted to make improvements to that game, but the thought of adding features or refactoring has held me back. The problem is, [it's written with a thousand lines of spaghetti jQuery.](https://github.com/mynar7/rpg/blob/master/assets/script.js) I can only imagine the challenge of working on a project like a banking application before frameworks came onto the scene.\n\n**Front-end frameworks are a response to the challenge of increased complexity and scale in web applications.** As we began making bigger web applications that do more and more for the user, we had to find a way to wrangle increasing amounts of logic, traffic, and code.\n\n**Frameworks handle the problem of scope by separating code into components**. A component can be purely visual, functional, or both. For the most part, JavaScript you write in a component is scoped to that component, providing isolation from other parts of the codebase. You don't have to worry as much about conflicting code when using components. **Components are also reusable**, meaning you can accomplish more with less code.\n\nFrameworks have performance benefits over plain JavaScript or jQuery. Specifically, **frameworks optimize re-rendering**, or in laymen's terms, updating the page's HTML. JavaScript's DOM API (all the `document.getElementById` stuff), is resource intensive for the browser. **Frameworks increase performance by minimizing the actual changes to the HTML**.\n\n**Frameworks also help mitigate large amounts of traffic to a website.** Instead of having one server build a new HTML file for each user and request, we can simply send the entire app to each user and let the user's browser handle re-rendering. This way the server only has to serve HTML/CSS/JS once, and can communicate to the browser with only data after that.\n\n### But...\n\nThere's a few downsides to frameworks. It's more JavaScript for the browser to run, which can be costly in terms of load times when a user first visits your site. It's also another layer of complexity for you to deal with as a developer, adding to your growing list of skills to maintain.\n\nIf you're building a static site like a business information page, you might not need a framework. But for complex applications like your banking website or the game I mentioned above, a framework can bring a lot to the table, albeit with its own costs.\n\n## The Big 3: Angular, React, and Vue\n\n![Three Horses, Photo by Doruk Yemenici](./threehorses.jpg)\n\nBefore we talk about picking a framework, let's talk about the differences between them. As of 2019, there's three big players in the JavaScript front-end framework game: Angular, React and Vue.\n\n### Angular\n\nAngular is a Google invention. It all started with AngularJS, which exploded onto the scene and saw widespread use. Then came React, and the Angular team rewrote the entire framework completely and called it Angular 2 (Then they skipped version 3 and went directly to 4 and we're currently on version 7).\n\nBasically AngularJS and Angular 2+ are completely different beasts, and so a large amount of the AngularJS crowd switched to React when version 2 came out.\n\n#### The Good\n\nAngular absolutely rocks for enterprise development. If you want to work for a big company, Angular is a fantastic choice. Angular is **batteries included**, meaning it comes with its own packages and solutions for the common things you want to do. For example, if you want to make an API call, there's a feature for that. Internationalization, Global State Management and other Angular libraries/features are all built and maintained by the Angular team.\n\n**Angular is also the most opinionated of the Big 3.** And because of its opinionated nature, **most Angular projects look the same**. When I say \"opinionated\" I mean that Angular has a particular method or way of doing what you want to accomplish. This means that once you learn it, you likely can work on any other Angular codebase with little effort.\n\n#### The Bad\n\nBeing opinionated is a double-edged sword. Yes, it means that everyone is probably doing something the same way, but remember that Angular was written by Google Engineers. So the \"Angular Way\" does not necessarily mean the easy way.\n\n**TypeScript is mandatory** in Angular, and **the Angular team loves RxJS**, so that's also rolled into the framework. NGRX, Angular's state management library, makes Redux look lightweight by comparison. All this adds up to a **fairly steep learning curve for the novice developer.**\n\nAngular also wraps its components in HTML elements in such a way that CSS is scoped by default. There's no way to turn it off either. Because of this, it can be incredibly difficult to override a component's CSS when you need to.\n\n#### The Ugly\n\nWorking with the module pattern in Angular is frustrating for beginners. Every component comes with an HTML, CSS, TypeScript, and Test file by default. You then have to register that component in a higher level module that tells Angular and TypeScript where it can find everything. The CLI has commands to generate a new component and auto-register it in a module because of how laborious it can be to do manually.\n\nIf you're still learning front-end development and you're new to frameworks, **Angular can feel like building a rocket launcher to swat a fly.** It's honestly overkill for a small application, the type of which you need to build a lot of when learning.\n\nTo boot, the documentation is not great, and the community is not as prolific as React or Vue's. This means it's harder to find solutions for your problems via Google, and there's not many tutorials out there for you to learn from.\n\nThat said, I recommend [Todd Motto's courses](https://ultimatecourses.com/author/toddmotto) and the [Angular Firebase fellow on YouTube](https://www.youtube.com/channel/UCsBjURrPoezykLs9EqgamOA) if you're hoping to learn Angular.\n\n### React\n\nReact, created by Facebook, launched after AngularJS and quickly became the most popular front-end framework.\n\nIf I had to put the React philosophy into words, I might say that **React wants to be as unobstrusive as possible and make you feel like you're just working with JavaScript**. React also highly values immutabililty and one-way data flow.\n\n#### The Good\n\nBecause of its popularity, **there are an absolute ton of resources to learn React.** You can hop onto Google or YouTube and easily find entire free courses for React. Any questions you may have about React have likely been answered and posted to Stack Overflow or some other forum.\n\nReact's popularity also means there is **plenty of 3rd party support**. If you need any kind of pre-built solution for any aspect of a React project, someone has undoubtedly already built it and published it to NPM.\n\nReact's API is also very small, meaning there's just not that much to it. **Writing React is a lot like writing JavaScript**, particularly with the new hooks API which emphasizes a **functional approach** to writing components. **This makes learning React beginner-friendly**.\n\nThe popularity of React also makes it a great skill for finding a job. Plenty of companies use React.\n\n#### The Bad\n\n**Because React is so small and un-opinionated, you're going to have to bring in your own solutions for everything.** This means you may be using lots of 3rd party libraries to accomplish things that might come standard in Angular or Vue. For example, if you want to make an API call, you'll probably use Axios or JS's fetch. If you want global state management, you're going to use Redux or some other solution, where Angular has NGRX and Vue has Vuex.\n\nBeing a \"bring your own everything\" framework, **one React project may look wildly different from another.** So just because you have worked with React at one company for a length of time, you might change jobs to another React-based team and find yourself on a strange and foreign codebase that you have to learn.\n\n#### The Ugly\n\nBecause it's \"just JavaScript\", **React will let you write a bunch of JavaScript and logic in your template.** This can make your code confusing and obtuse to other developers, and even yourself on a second pass. **It can be incredibly difficult to write JSX in a way that's readable.**\n\nReact is un-opinionated, so you can absolutely turn it into a footgun and begin writing code that's not performant and full of bugs. **It's incredibly easy to write bad React code.**\n\n### Vue\n\nVue is the underdog, and everyone loves a good underdog. It's written by Evan You, a former AngularJS team member. This the only one of the Big 3 not backed by a huge company in Silicon Valley.\n\n#### The Good\n\nVue's API is **incredibly easy to learn**. There's plenty of stories of designers and developers that were turned-off or confused by Angular/React that gravitated towards Vue and loved it.\n\nVue provides just enough opinion to keep your code readable and sane without making you feel like you're jumping through hoops to use it. It also provides some excellent built-in solutions for common framework problems. For instance, state management is greatly simplifed through Vuex, Vue's version of Redux/NGRX.\n\nThere's also a **good amount of community support**; there's plenty of third party libraries and packages for Vue. There's also plenty of tutorials and info to be found on Google for Vue. **And the official documentation is excellent.**\n\nIf you're worried about jobs with Vue, it's a valid concern. You're probably not as likely to find a Vue job in the states as an Angular or React job. However, the PHP community loves Vue. **Laravel ships with Vue, and so if you find a company writing PHP, you're likely to also find them using Vue.** Vue is also huge in Asia likely because the documentation has been translated to Asian languages.\n\n#### The Bad\n\nSharing logic between components with Vue is currently a bit of a mess. \"Mixins\" let you write logic that can be shared between components. They're easy enough to use, but it can be devilish trying to figure out how mixins interact with a components logic. **Mixins are terrible.**\n\nVue also doesn't really play well with TypeScript currently, which is a concern for big codebases that could benefit from it.\n\nAnd as I noted above, you _might_ have a harder time finding work in the West as a Vue dev than you would if you had learned React/Angular.\n\n#### The ...Uncertain\n\nVue isn't ugly. It's _vuetiful_.\n\nThat said, Version 3 of Vue is coming, and it's bringing a different API with it that mimics React hooks.\n\nNow, React hooks are **excellent**, but it remains to be seen how well Vue hooks (or the Composition API) will be embraced by the community. Regardless, Vue 3 will be backwards compatible, so hooks will be opt-in.\n\nHaving used React hooks, and having seen what Vue hooks are bringing to the table, I am excited to give them a try.\n\n### What about Ember, Svelte, Backbone, etc?\n\nThere's a lot of front-end frameworks out there that aren't the big 3. Someone probably published a new one while you were reading this article. Here's a few I didn't mention:\n\n- **Ember** is another highly-opinionated framework, and while it's not as popular, there are teams out there using it.\n- **Svelte** is so new that nobody is using it yet. The creator is brilliant, and this may blow up, so who knows?\n- Nobody uses **backbone**. Sorry backbone.\n- **Lit-HTML/Polymer** is an ultra-lightweight framework (like 30 lines of JS small or something). I don't know of anyone using it.\n\n## Choosing a Framework\n\n![Man riding a horse, lighting his path with a lanterm by Priscilla De Preez](./lanternrider.jpg)\n\nNow that we've talked about the big 3, how do you pick one to learn?\n\nYou'll probably spend most of your time using one framework. A codebase is unlikely to pull in multiple frameworks, and as a developer you likely only have time to specialize in one framework at a time.\n\nThe truth is: **it doesn't really matter which framework you know, as long as you know one**.\n\nAll of these frameworks do the same thing. You write a template, variables and logic and they re-render the template based on those variables and logic.\n\nThey all use webpack and babel, they all have build-steps and CLIs, and you can get the same apps written using all of them. **They're all just HTML, CSS and JavaScript at the end of the day.**\n\nYour skills in one will transfer to another, because you're really learning web development before you're learning Angular or React development.\n\nWith that said, **choose the framework that aligns with your goals and preferences**.\n\nIf you want to move to Asia and work as a developer, Vue is a solid choice. Are you a Java developer or want to work at a big corporation? Angular might be best for you. Are you self-taught? Maybe React is the best choice simply for the amount of free tutorials that are available.\n\n## Parting Thoughts\n\nLearning the conventions and basics of a front-end framework is the hard part. **Once you learn one, it becomes trivial to switch to another.** I learned React in a boot camp, got hired at a big company that used Angular, and then changed jobs to another that used Vue.\n\n**Note**: If you're curious about how web development evolved from Geocities to React, I did [a brief talk on the history of web development and its current landscape.](https://www.youtube.com/watch?v=-W2hZadx8fE)","internal":{"contentFilePath":"/home/lee/dev/side_projects/blog/content/blog/angular-vs-react-vs-vue/index.md"}},"next":{"id":"6b14c7b4-5f94-5cb9-9efa-63b0717f40da","fields":{"slug":"/the-problem-with-context/"},"frontmatter":{"title":"The Problem with React's Context API"},"body":"![A Gorilla looking thoughtful by Rob Schreckhise](gorilla.jpg)\n\nReact's context API is awesome. As someone that looked at Redux as a junior developer and instantly felt defeated, learning about context was a relief. I used it in my apps, quickly forgot about Redux, and never looked back.\n\nThat is, until I heard about the supposed performance problems with the Context API. Now, the big names in the React community will tell you not to worry about performance unless you start seeing issues. And yet, I keep hearing about context problems from other developers. One fellow even mentioned his boss banning the use of Context on their project.\n\nLet's review the Context API in case you're unfamiliar before we talk about its problems.\n\n## Why use the context API?\n\nThe Context API is useful for sharing state between components that you can't easily share with props. Here's an example of a button component that needs to set the state of a distant ancestor:\n\n```jsx react-live use-render\nconst { useState } = React\n\nfunction CountDisplay({ count }) {\n  return <h2>The Count is: {count}</h2>\n}\n\nfunction CountButton({ setCount }) {\n  return (\n    <button onClick={() => setCount(count => count + 1)}>\n      Increment\n    </button>\n  )\n}\n\nconst OuterWrapper = ({setCount}) => <InnerWrapper setCount={setCount}/>\nconst InnerWrapper = ({setCount}) => <CountButton setCount={setCount}/>\n\nfunction App() {\n  const [count, setCount] = useState(0)\n  return (\n    <div>\n      <CountDisplay count={count} />\n      <OuterWrapper setCount={setCount}/>\n    </div>\n  )\n}\n\nrender(App)\n```\n\nThe button component is within a few other components further down the tree, but still needs to access state from higher up in the app. So we have to pass `setCount` down to each component to finally get it to our `CountButton` component. This is affectionately known as \"prop-drilling\", and used to be a huge pain point in React.\n\nThe Context API makes short work of situations like this, thankfully.\n\n## How to use the Context API\n\nKent C. Dodds has a fantastic [blog post](https://kentcdodds.com/blog/application-state-management-with-react) that I refer to whenever I implement the Context API. If you don't have time to read that, here's the short version: Context is a way to share state between unrelated or distant components. All you have to do is wrap your components in a `Context.Provider` and then call `useContext(Context)` inside that component to access your state and helper functions.\n\nHere's our counter example with context:\n\n```jsx react-live use-render\nconst {useContext, useState, createContext} = React\n\nconst AppContext = createContext()\n\nfunction AppProvider(props) {\n  const [count, setCount] = useState(0)\n  const value = { count, setCount }\n  return (\n    <AppContext.Provider value={value}>\n      {props.children}\n    </AppContext.Provider>\n  )\n}\n\nfunction CountDisplay() {\n  const { count } = useContext(AppContext)\n  return <h2>The Count is: {count}</h2>\n}\n\nfunction CountButton() {\n  const { setCount } = useContext(AppContext)\n  return (\n    <button onClick={() => setCount(count => count + 1)}>\n      Increment\n    </button>\n  )\n}\n\nconst OuterWrapper = () => <InnerWrapper />\n\nconst InnerWrapper = () => <CountButton />\n\nfunction App() {\n  return (\n    <div>\n      <AppProvider>\n        <CountDisplay/>\n        <OuterWrapper/>\n      </AppProvider>\n    </div>\n  )\n}\n\nrender(App)\n```\n\nHere we have `CountDisplay` and `CountButton` components that both need to interact with the higher-level `count` state in our context. We start by making a context with `createContext`, then a provider component in `AppProvider` to wrap our dependent components, and finally call `useContext` in each component to pull out the values we need. It doesn't matter how far apart the components are as long as they're wrapped in a provider.\n\nPretty great right?\n\n## Kent C. Dodd's Optimizations üìà\n\nWe can improve on this a little bit by implementing some stuff that Kent has in his article on state management. Let's take a look:\n\n```jsx react-live use-render\nconst {useContext, useState, createContext, useMemo} = React\nconst AppContext = createContext()\n\n// instead of calling useContext directly in our components,\n// we make our own hook that throws an error if we try to\n// access context outside of the provider\nfunction useAppContext() {\n  const context = useContext(AppContext)\n  if (!context)\n    throw new Error('AppContext must be used with AppProvider!')\n  return context\n}\n\nfunction AppProvider(props) {\n  const [count, setCount] = useState(0)\n  // here we use useMemo for... reasons.\n  // this says don't give back a new count/setCount unless count changes\n  const value = useMemo(() => ({ count, setCount }), [count])\n  return <AppContext.Provider value={value} {...props} />\n}\n\nfunction CountDisplay() {\n  const { count } = useAppContext()\n  return <h2>The Count is: {count}</h2>\n}\n\nfunction CountButton() {\n  const { setCount } = useAppContext()\n  return (\n    <button onClick={() => setCount(count => count + 1)}>\n      Increment\n    </button>\n  )\n}\n\nconst OuterWrapper = () => <InnerWrapper />\n\nconst InnerWrapper = () => <CountButton />\n\nfunction App() {\n  return (\n    <div>\n      <AppProvider>\n        <CountDisplay />\n        <OuterWrapper />\n      </AppProvider>\n    </div>\n  )\n}\n\nrender(App)\n```\n\nThe first thing we do is throw an error if we try to access the context outside of our provider. This is a great idea to improve the developer experience of your app (aka: make the console scream at you when you forget how context works).\n\nThe second thing is to memoize our context value to only re-render if the `count` changes. Now, `useMemo` is a difficult thing to wrap your head around, but the basic gist is that when you memoize something, you're saying that you won't return that value again unless your specified value changes. Kent has a [great article](https://kentcdodds.com/blog/usememo-and-usecallback) on that too if you want to read more.\n\nI can't discern a difference between using `useMemo` and not using it, but I would venture that if you're doing some heavy lifting in your Context Provider, it might be beneficial to apply memoization. If you read Kent's article on `useMemo` and `useCallback` he cautions against using them unless you start to see performance hits. (Full Disclosure: I've never needed to use either one.)\n\nKent also spreads his `props` on the provider instead of using `props.children`, which is a neat trick, so I included that as well.\n\n## The Context API's Dirty Little Secret ü§´\n\n![Man making the shush gesture with his finger over his lip, laying on a mound of trash. Photo by Jordan Beltran](trashman.jpg)\n\nBoy, the Context API sure is great. It's super easy to use compared to Redux and requires a lot less code, so why _wouldn't_ you use it?\n\nThe problem with context is simple: **Everything that consumes a context re-renders everytime that context's state changes.**\n\nThat means that if you're consuming your context all over the place in your app, or worse, using one context for your entire app's state, you're causing a ton of re-renders all over the place!\n\nLet's visualize this with a simple app. Let's make a context with a counter and a message. The message will never change, but be consumed by three components that display the message in a random color on each render. The count will be consumed by one component, and be the only value that changes.\n\nThat sounds like a middle school math problem, but if you look at this code and the resulting app, the problem becomes blatantly obvious:\n\n```jsx react-live use-render\nconst {useContext, useState, createContext} = React\nconst AppContext = createContext()\n\nfunction useAppContext() {\n  const context = useContext(AppContext)\n  if (!context)\n    throw new Error('useAppContext must be used within AppProvider!')\n  return context\n}\n\nfunction AppProvider(props) {\n  // the count for our counter component\n  const [count, setCount] = useState(0)\n  // this message never changes!\n  const [message, setMessage] = useState('Hello from Context!')\n  const value = {\n    count,\n    setCount,\n    message,\n    setMessage\n  }\n  return <AppContext.Provider value={value} {...props}/>\n}\n\nfunction Message() {\n  const { message } = useAppContext()\n  // the text will render to a random color for\n  // each instance of the Message component\n  const getColor = () => (Math.floor(Math.random() * 255))\n  const style = {\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\n  }\n  return (\n    <div>\n      <h4 style={style}>{message}</h4>\n    </div>\n  )\n}\n\nfunction Count() {\n  const {count, setCount} = useAppContext()\n  return (\n    <div>\n      <h3>Current count from context: {count}</h3>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <div>\n      <AppProvider>\n        <h2>Re-renders! üò©</h2>\n        <Message />\n        <Message />\n        <Message />\n        <Count />\n      </AppProvider>\n    </div>\n  )\n}\nrender(App)\n```\nEverything re-renders when we click increment üò±.\n\nThe message components don't even use the `count` from our context, but they re-render anyway. Yikes!\n\n### What about memoization?\n\nMaybe we just forgot to use `useMemo` like Kent did in his example. Let's memoize our context and see what happens:\n\n```jsx react-live use-render\nconst {useContext, useState, createContext, useMemo} = React\nconst AppContext = createContext()\n\nfunction useAppContext() {\n  const context = useContext(AppContext)\n  if (!context) throw new Error('useAppContext must be used within AppProvider!')\n  return context\n}\n\nfunction AppProvider(props) {\n  const [count, setCount] = useState(0)\n  const [message, setMessage] = useState('Hello from Context!')\n  // here we pass our value to useMemo,\n  // and tell useMemo to only give us new values\n  // when count or message change\n  const value = useMemo(() => ({\n    count,\n    setCount,\n    message,\n    setMessage\n  }), [count, message])\n  return <AppContext.Provider value={value} {...props}/>\n}\n\nfunction Message() {\n  const { message } = useAppContext()\n  const getColor = () => (Math.floor(Math.random() * 255))\n  const style = {\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\n  }\n  return (\n    <div>\n      <h4 style={style}>{message}</h4>\n    </div>\n  )\n}\n\nfunction Count() {\n  const {count, setCount} = useAppContext()\n  return (\n    <div>\n      <h3>Current count from context: {count}</h3>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <div>\n      <AppProvider>\n        <h2>Re-renders! üò©</h2>\n        <Message />\n        <Message />\n        <Message />\n        <Count />\n      </AppProvider>\n    </div>\n  )\n}\nrender(App)\n```\n\nNope! Memoization with `useMemo` doesn't help at all!\n\n### What about components that don't consume Context, do they re-render?\n\nThat's an excellent question, let's test it with a Message component that doesn't consume context:\n\n```jsx react-live use-render\nconst {useContext, useState, createContext, useMemo} = React\nconst AppContext = createContext()\n\nfunction useAppContext() {\n  const context = useContext(AppContext)\n  if (!context) throw new Error('useAppContext must be used within AppProvider!')\n  return context\n}\n\nfunction AppProvider(props) {\n  const [count, setCount] = useState(0)\n  const [message, setMessage] = useState('Hello from Context!')\n  const value = useMemo(() => ({\n    count,\n    setCount,\n    message,\n    setMessage\n  }), [count, message])\n  return <AppContext.Provider value={value} {...props}/>\n}\n\n// this component does NOT consume the context\n// but is still within the Provider component\nfunction IndependentMessage() {\n  const getColor = () => (Math.floor(Math.random() * 255))\n  const style = {\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\n  }\n  return (\n    <div>\n      <h4 style={style}>I'm my own Independent Message!</h4>\n    </div>\n  )\n}\n\nfunction Message() {\n  const { message } = useAppContext()\n  const getColor = () => (Math.floor(Math.random() * 255))\n  const style = {\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\n  }\n  return (\n    <div>\n      <h4 style={style}>{message}</h4>\n    </div>\n  )\n}\n\nfunction Count() {\n  const {count, setCount} = useAppContext()\n  return (\n    <div>\n      <h3>Current count from context: {count}</h3>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <div>\n      <AppProvider>\n        <h2>Re-renders! üò©</h2>\n        <Message />\n        <Message />\n        <Message />\n        <IndependentMessage />\n        <Count />\n      </AppProvider>\n    </div>\n  )\n}\nrender(App)\n```\n\nWell, this is the only good news so far. **Only components that call `useContext` re-render whenever the context's state changes.**\n\nStill, this is bad news for our app. We don't want to trigger a bunch of unnecessary re-renders everywhere we use a context.\n\nImagine if those message components were doing a lot of work like calculating animations, or if we had a huge React app with lots of components dependent on our context. That could lead to pretty serious performance issues, right?\n\n## Should we stop using Context?\n\n![Sign showing man throwing away trash, photo by Gary Chan](trash.jpg)\n\nI'll go ahead and say this now: **no, this isn't a reason to stop using context**. There's a ton of apps out there using context and chugging along just fine, including a bunch of my own apps.\n\nStill, performance is kind of a big deal. I don't want to leave you sitting up at night worrying about the Context API's dirty little secret. So let's talk about some ways to deal with this re-render business.\n\n### Option 1: Don't worry at all. Keep on Context'n like you do. YOLO ü§™!\n\nI've basically used Context a whole bunch in a lot of various apps without memoization, at the top level of my app, and consumed by a bunch of components without noticing any performance hits at all. Like I said before, a lot of the React folks say you shouldn't even worry about performance optimizations until you see performance impacts.\n\nStill, this strategy won't work for everyone. You may already have performance issues in your app, or if your app processes a lot of logic or animations, you may see performance issues as your app grows and end up doing some serious refactoring down the road.\n\n### Option 2: Use Redux or Mobx\n\nRedux and Mobx both use the context API, so how do they help? The store that's shared by these state management libraries with context is a little different from sharing state directly with context. When you're using Redux and Mobx, there's a diffing algorithm at work that makes sure to only re-render the components that actually need to re-render.\n\nStill, context was supposed to save us from having to learn Redux and Mobx! There's a lot of abstractions and boilerplate involved in using a state management library, making it an unattractive solution to some folks.\n\nPlus, isn't keeping all of our state in global state a bad practice?\n\n### Option 3: Use Multiple Contexts, and keep state close to its Dependent Components\n\nThis solution takes the most finesse to pull off, but gives you the best performance without reaching for Redux and Mobx. It relies on being smart about your state management choices, and only passing state up to a context if you need to share it between distant components.\n\nThere's a few key tenants to this strategy:\n\n1. **Let a component manage its own state if it can.** This is a good practice to follow regardless of your choice of state management. For example, if you have a modal that needs to keep track of an open/closed state, but no other components need to know if that modal is open, keep that open/closed state in the modal. Don't push state into context (or Redux) if you don't have to!\n1. **If your state is shared between a parent and a few children, just prop it down.** This is the old school method of sharing state. Just pass it as props to the children components that need it. Passing props or \"Prop-drilling\" can be miserable with deeply nested components, but if you're only passing things down a few levels, you should probably just do it.\n1. **If the previous two things fail, use context but keep it close to the components that depend on it.** This means if you need to share some state, like a form for instance with multiple components, go ahead and make a separate context for just the form and wrap the form components in your provider.\n\nThat last one deserves an example. Let's apply it to our problem app from before. We can fix those re-renders by separating the `message` and `count` into their own contexts.\n\n```jsx react-live use-render\nconst { useContext, useState, createContext } = React\nconst CountContext = createContext()\n\n// Now count context only worries about count!\nfunction useCountContext() {\n  const context = useContext(CountContext)\n  if (!context)\n    throw new Error('useCountContext must be used within CountProvider!')\n  return context\n}\n\nfunction CountProvider(props) {\n  const [count, setCount] = useState(0)\n  const value = { count, setCount }\n  return <CountContext.Provider value={value} {...props}/>\n}\n\n// And message context only worries about message!\nconst MessageContext = createContext()\n\nfunction useMessageContext() {\n  const context = useContext(MessageContext)\n  if (!context)\n    throw new Error('useMessageContext must be used within MessageProvider!')\n  return context\n}\n\nfunction MessageProvider(props) {\n  const [message, setMessage] = useState('Hello from Context!')\n  const value = { message, setMessage }\n  return <MessageContext.Provider value={value} {...props}/>\n}\n\nfunction Message() {\n  const { message } = useMessageContext()\n  const getColor = () => (Math.floor(Math.random() * 255))\n  const style = {\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\n  }\n  return (\n    <div>\n      <h4 style={style}>{message}</h4>\n    </div>\n  )\n}\n\nfunction Count() {\n  const {count, setCount} = useCountContext()\n  return (\n    <div>\n      <h3>Current count from context: {count}</h3>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n    </div>\n  )\n}\n\nfunction App() {\n  return (\n    <div>\n      <h2>No Unnecessary Re-renders! üòé</h2>\n      <MessageProvider>\n        <Message />\n        <Message />\n        <Message />\n      </MessageProvider>\n      <CountProvider>\n        <Count />\n      </CountProvider>\n    </div>\n  )\n}\nrender(App)\n```\n\nNow our state is only shared with the components that care about that state. When we increment, the colors of our message components stay the same because `count` lives outside of `messageContext`.\n\n## Final Thoughts\n\nAlthough this article's title is a little incendiary and the \"problem\" with context  may not be the boogie man some might envision it to be, I still think this is worth talking about. React's flexibility makes it both a great framework for beginners as well as a devastating footgun for those that don't know its inner-workings. I don't forsee a lot of people tripping over this particular detail, but if you're using context and seeing performance issues, it's a good thing to know!","internal":{"contentFilePath":"/home/lee/dev/side_projects/blog/content/blog/the-problem-with-context/index.md"}},"frontmatter":{"title":"What are debounce and throttle functions, and how do you write them in JavaScript and React?","date":"2019-10-17T12:00:00-0400"}}},"staticQueryHashes":["2836739900","4250957540"],"slicesMap":{}}