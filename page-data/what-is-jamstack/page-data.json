{"componentChunkName":"component---src-templates-blog-post-js","path":"/what-is-jamstack/","webpackCompilationHash":"7cdaf23ceefbd7dfc1e9","result":{"data":{"site":{"siteMetadata":{"title":"Strings and Things","author":"Lee Warrick"}},"mdx":{"id":"4207d0dd-1956-5776-9977-438da9b10b51","excerpt":"JAMstack is one of those buzzwords that leaves the listener confused whenever it's uttered (see also PWAs, blockchain, and serverless). Despite the name, JAMstack is a fantasticâ€¦","frontmatter":{"title":"Just what is JAMstack, anyway?","date":"January 18, 2020"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Just what is JAMstack, anyway?\",\n  \"date\": \"2020-01-18T12:00:00-0400\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"590px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/blog/static/2cac76f5c8384426ef46e8a929e5f9f2/971c4/jamstack.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": [\"noopener\"]\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.5%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Jars of jam stacked on a shelf. A literal jamstack. Photo by Viktor Forgacs on https://unsplash.com/photos/5mGGOWD-Ths\",\n    \"title\": \"Jars of jam stacked on a shelf. A literal jamstack. Photo by Viktor Forgacs on https://unsplash.com/photos/5mGGOWD-Ths\",\n    \"src\": \"/blog/static/2cac76f5c8384426ef46e8a929e5f9f2/c739e/jamstack.jpg\",\n    \"srcSet\": [\"/blog/static/2cac76f5c8384426ef46e8a929e5f9f2/8ee9c/jamstack.jpg 148w\", \"/blog/static/2cac76f5c8384426ef46e8a929e5f9f2/ebbe7/jamstack.jpg 295w\", \"/blog/static/2cac76f5c8384426ef46e8a929e5f9f2/c739e/jamstack.jpg 590w\", \"/blog/static/2cac76f5c8384426ef46e8a929e5f9f2/5413e/jamstack.jpg 885w\", \"/blog/static/2cac76f5c8384426ef46e8a929e5f9f2/971c4/jamstack.jpg 1000w\"],\n    \"sizes\": \"(max-width: 590px) 100vw, 590px\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"JAMstack is one of those buzzwords that leaves the listener confused whenever it\\u2019s uttered (see also PWAs, blockchain, and serverless). Despite the name, JAMstack is a fantastic choice for front-end web applications, and definitely worth your time as a front-end developer.\"), mdx(\"p\", null, \"However, defining \\u201CJAMstack\\u201D is a tricky thing, and the community knows it. There\\u2019s why there\\u2019s sites like \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jamstack.wtf\"\n  }), \"jamstack.wtf\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://jamstack.org\"\n  }), \"jamstack.org\"), \" devoted to explaining just what it is.\"), mdx(\"p\", null, \"Unfortunately, you have to have a solid understanding of web development technologies before explanations of JAMstack start to make sense. So let\\u2019s start with the basics.\"), mdx(\"h2\", null, \"Let\\u2019s Review\"), mdx(\"p\", null, \"When I started out as a developer, I had \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"some\"), \" knowledge of the front-end ecosystem I was entering. There was of course JavaScript, HTML, and CSS, plus single page application (SPA) frameworks like React, Angular, and Vue. I understood two potential options for making web apps with this tooling.\"), mdx(\"p\", null, \"The first is the old-school \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"server-rendered\"), \" route: build your pages in HTML/CSS/JS ahead of time and let the server serve those. Or you could have the server build those pages with a templating language (handlebars, EJS, jinja, etc) as requests came in. The downside here was that either your content was static (that\\u2019s no fun), or your server was doing a lot of work. Plus, each time the user requested a new page they would see a white screen as the server built/found the page and sent it to the user\\u2019s browser.\"), mdx(\"p\", null, \"The more modern method uses \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"client-side rendering\"), \". You write an SPA, and send a big payload of JavaScript to your user upfront when they visit your site. This is the buy-once, cry-once method. The user waits while all the JavaScript downloads, then again while it renders the requested page. After that initial hit, the app is buttery smooth and provides a great experience, because each page change after that is rendered with JavaScript running in the user\\u2019s browser. Still, that initial page-load is the important one. Users are impatient, and a long initial load time means you\\u2019re losing traffic.\"), mdx(\"p\", null, \"This always made me think of those signs you see in restaurants and mechanic shops. You know the one:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"We offer three kinds of Services:\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"GOOD - FAST - CHEAP\"), mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"\\u2026but you can only pick \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"two\"), \".\")), mdx(\"h2\", null, \"The Chimera Option\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"590px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/blog/static/6fae55ed7800e31c097a4ef6233dd7dc/a296c/chimera.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": [\"noopener\"]\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"69.25%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Photo of The Chimera of Arezzo, c. 400 BC, found in Arezzo, an ancient Etruscan and Roman city in Tuscany, Museo Archeologico Nazionale, Florence. By Carole Raddato. From https://www.flickr.com/photos/carolemage/22636282885\",\n    \"title\": \"Photo of The Chimera of Arezzo, c. 400 BC, found in Arezzo, an ancient Etruscan and Roman city in Tuscany, Museo Archeologico Nazionale, Florence. By Carole Raddato. From https://www.flickr.com/photos/carolemage/22636282885\",\n    \"src\": \"/blog/static/6fae55ed7800e31c097a4ef6233dd7dc/c739e/chimera.jpg\",\n    \"srcSet\": [\"/blog/static/6fae55ed7800e31c097a4ef6233dd7dc/8ee9c/chimera.jpg 148w\", \"/blog/static/6fae55ed7800e31c097a4ef6233dd7dc/ebbe7/chimera.jpg 295w\", \"/blog/static/6fae55ed7800e31c097a4ef6233dd7dc/c739e/chimera.jpg 590w\", \"/blog/static/6fae55ed7800e31c097a4ef6233dd7dc/a296c/chimera.jpg 800w\"],\n    \"sizes\": \"(max-width: 590px) 100vw, 590px\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"It turns out there\\u2019s another option. This is where things start to get sticky, though. Single page applications are already difficult to think about, and typically we like to think about them as using client-side, on-demand rendering only. However it\\u2019s now possible to mix and match dynamic and static content on both the client and server.\"), mdx(\"p\", null, \"There\\u2019s two main camps using this hybrid methodology to web app rendering and delivery. The first is server-rendered single page applications, and the second is JAMstack.\"), mdx(\"h3\", null, \"Server-Rendered SPAs\"), mdx(\"p\", null, \"With a server-rendered SPA, you have to maintain your own server. On initial hit the server pre-renders the page the user requested in HTML/CSS and sends it down to the user. This means the users gets to see a dynamically-rendered page relatively quickly. The server also sends a mess of JavaScript that loads in the background. Now when the user navigates to the next page, the app functions like an SPA and uses that mess of JavaScript to render the new page, instead of asking the server for it. The app only asks the server for data (typically JSON) after that initial page-load.\"), mdx(\"p\", null, \"Some examples of this technology are \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://nextjs.org/\"\n  }), \"NextJS\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://nuxtjs.org/\"\n  }), \"NuxtJS\"), \" and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://angular.io/guide/universal\"\n  }), \"Angular Universal\"), \". For what it\\u2019s worth, I\\u2019ve used both NextJS and NuxtJS, and they are both fantastic.\"), mdx(\"p\", null, \"The only problem with this method is that, again, you need to maintain your own server. Running your own server is much more costly than a static hosting solution (using someone else\\u2019s server). There\\u2019s also some potential security liability involved.\"), mdx(\"h3\", null, \"Pre-Rendered SPAs\"), mdx(\"p\", null, \"You\\u2019re probably thinking this is a bit silly. The whole point of an SPA is to have a dynamic, on-the-fly rendering of your application at any given point, right? If you pre-render everything, what are you left with?\"), mdx(\"p\", null, \"The answer is a lot, actually. When we build a single page app, we often have various routes or views baked in that don\\u2019t change. You may have a \\u201Chome\\u201D page, an \\u201Cabout\\u201D page, and then your \\u201Cmain\\u201D content. Those home and about changes don\\u2019t really require dynamic data to render anything, but with a traditional SPA they\\u2019re rendered dynamically all the same. Even the \\u201Cmain\\u201D stuff probably lives on a route in some kind of wrapper component, right?\"), mdx(\"p\", null, \"With a pre-rendered SPA, when we \\u201Cbuild\\u201D the application (bundle with Webpack) we designate what can be safely pre-rendered and what needs to be left alone to render on the client\\u2019s machine at runtime. Then our bundler pre-renders as much of the application as possible (all the routes), and leaves the rest to be rendered with JavaScript at runtime.\"), mdx(\"p\", null, \"Instead of a single HTML page in your build folder as an entrypoint to your app, you\\u2019ll have multiple. So when the user asks to visit the \\u201Cabout\\u201D page instead of the home page, that \\u201Cabout\\u201D page HTML file is ready before the request comes in. After that initial page-load, the JavaScript takes over and handles the page transitions and dynamic portions of the application.\"), mdx(\"p\", null, \"The result is an SPA that has a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"fast\"), \" initial load, instead of a long initial load, meaning a great user experience without the cost and maintenance of a server.\"), mdx(\"p\", null, \"Some examples of this technology are \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.gatsbyjs.org/\"\n  }), \"GatsbyJS\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://gridsome.org/\"\n  }), \"Gridsome\"), \", \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://nextjs.org/features/static-exporting\"\n  }), \"NextJS\"), \", and \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://nuxtjs.org/guide#static-generated-pre-rendering\"\n  }), \"NuxtJS\"), \".\"), mdx(\"p\", null, \"Gatsby and Gridsome are more purpose-built for \\u201Cstatic\\u201D-site generation, while Next and Nuxt are swiss army knife tools that allow you to do both server-rendering and static-site generation.\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note\"), \": There\\u2019s a lot of confusion about Static-Site Generators (SSG). A traditional SSG (Hugo, Jekyll, etc) takes your templated code and generates static HTML files from it. Gatsby and Gridsome are actually a lot more than SSGs. They allow you to smartly pre-build and template content in a lot of various ways.\"), mdx(\"p\", null, \"For example, this blog is built from markdown files, and at build time, Gatsby compiles the markdown files into a React application. You could also query an API or CMS like Wordpress to get your data dynamically at build time. However you\\u2019re still free to make API calls at runtime too. \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"You\\u2019re still building a React app\"), \". You\\u2019re just pre-rendering some of it.\"), mdx(\"h2\", null, \"Are you going to talk about JAMstack or not?\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"590px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/blog/static/ae37e1c37847fdb615b08e028b0cc707/971c4/impatient.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": [\"noopener\"]\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.7%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Incredulous looking woman with furrowed brow. Photo by Jeffrey Wegrzyn on https://unsplash.com/photos/K-chxjiTu7c\",\n    \"title\": \"Incredulous looking woman with furrowed brow. Photo by Jeffrey Wegrzyn on https://unsplash.com/photos/K-chxjiTu7c\",\n    \"src\": \"/blog/static/ae37e1c37847fdb615b08e028b0cc707/c739e/impatient.jpg\",\n    \"srcSet\": [\"/blog/static/ae37e1c37847fdb615b08e028b0cc707/8ee9c/impatient.jpg 148w\", \"/blog/static/ae37e1c37847fdb615b08e028b0cc707/ebbe7/impatient.jpg 295w\", \"/blog/static/ae37e1c37847fdb615b08e028b0cc707/c739e/impatient.jpg 590w\", \"/blog/static/ae37e1c37847fdb615b08e028b0cc707/5413e/impatient.jpg 885w\", \"/blog/static/ae37e1c37847fdb615b08e028b0cc707/971c4/impatient.jpg 1000w\"],\n    \"sizes\": \"(max-width: 590px) 100vw, 590px\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Yes! Now we can talk about what is and isn\\u2019t JAMstack. JAMstack stands for JavaScript, APIs, and markup. I find that definition entirely unhelpful, hence the lengthy lead-in for this segment.\"), mdx(\"p\", null, \"JAMstack is really about making awesome websites without running your own server, or at least decoupling your \\u201Cstatic\\u201D front-end from your back-end data sources. The front-end app should be composed of static files \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"only\"), \" and be its own codebase. That means \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"no server-rendered content\"), \".\"), mdx(\"p\", null, \"This sounds a little restrictive, but trust me, you can build \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"a lot\"), \" of dynamic content following these rules. Just about anything you can build with create-react-app or an SPA can be a JAMstack site. You can build Blogs, e-commerce sites, marketing pages, and full on web apps all with JAMstack methods.\"), mdx(\"p\", null, \"Clear as mud, right?\"), mdx(\"h3\", null, \"JAMstack FAQ:\"), mdx(\"p\", null, \"I had a lot of questions on my journey to understanding JAMstack. Let\\u2019s try to address some of those points of confusion.\"), mdx(\"h4\", null, \"If it\\u2019s pre-rendered, how do I update it?\"), mdx(\"p\", null, \"You have to rebuild the site/app everytime you update something that is pre-rendered. So if I make a new blog post, I have to rebuild the site and redeploy it.\"), mdx(\"p\", null, \"However, that doesn\\u2019t mean you have to redeploy everytime your app needs to make an API call. Remember that your site can still run JavaScript on the front-end.\"), mdx(\"h4\", null, \"If I have to redeploy to update the site, how do my users make updates?\"), mdx(\"p\", null, \"Ah yes, consider the scenario where you make a blog for someone else. They probably don\\u2019t want to write posts in markdown and push code to github, right? That\\u2019s OK! You can automate your build step. If they make a new post, all you need to do is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"trigger\"), \" a build to happen.\"), mdx(\"p\", null, mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://www.netlifycms.org/\"\n  }), \"Netlify CMS\"), \" is based around this idea. The user makes their edits on a dashboard (also an SPA), and when they \\u201Csave\\u201D, they\\u2019re really committing the code with git, which then triggers a rebuild.\"), mdx(\"h4\", null, \"I don\\u2019t want my users touching git. Ever. I\\u2019d rather use Wordpress.\"), mdx(\"p\", null, \"Ah, but you can do that too! You\\u2019d have to host your own Wordpress server somewhere, but Wordpress has a JSON API. When your user makes a new post, you simply have to trigger your static site to build somehow. If you\\u2019re using Gatsby or Gridsome, the build step queries your Wordpress API (or any other CMS, really) for all the available posts and builds the site.\"), mdx(\"h4\", null, \"What about user comments on blog posts?\"), mdx(\"p\", null, \"That\\u2019s OK! You can still do all the things we just talked about, and just make a API calls for comments on the fly at runtime. You could build your own comment microservice, or use a premium service \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://fauna.com/\"\n  }), \"FaunaDB\"), \" to store comments for you.\"), mdx(\"h4\", null, \"What are the advantages to JAMstack?\"), mdx(\"p\", null, \"Typically, you can have faster page loads and a much better user experience using JAMstack methods. Also, because your front-end is detached from the server, security issues are greatly diminished. Plus, it\\u2019s mostly free or at least very cheap to host a static site.\"), mdx(\"h4\", null, \"When wouldn\\u2019t I use JAMstack for a site then?\"), mdx(\"p\", null, \"If all of your front-end content needs to be generated on the fly, JAMstack is not a great choice. For example, if you need dynamic routes, that makes it very difficult to build a static front-end app. Similarly, if you\\u2019re building a server anyway, maybe it makes more sense to serve the front-end as well.\"), mdx(\"h4\", null, \"Can you show me some examples of JAMstack sites?\"), mdx(\"p\", null, \"Sure! I\\u2019ve built a whole mess of them.\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://leewarrick.com/blog\"\n  }), \"My blog\"), \" - Built with Gatsby, hosted on Github Pages\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://techjr.dev\"\n  }), \"The Tech JR Podcast site\"), \" - Built with Gridsome, hosted on Netlify and mp3s stored on AWS S3\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://leewarrick.com/babelfish\"\n  }), \"Babelfish, a translation app\"), \" - Built with Gatsby and Google\\u2019s translation API, hosted on Github pages\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://leewarrick.com/goaler\"\n  }), \"Goaler, a todo app\"), \" - Built with Create-React-App and Firebase, hosted on Github Pages\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"a\", _extends({\n    parentName: \"li\"\n  }, {\n    \"href\": \"https://leewarrick.com/pokemon-cards\"\n  }), \"This Pokedex App\"), \" - Built with the Vue CLI and the Poke-API, hosted on Github Pages\")), mdx(\"h2\", null, \"Parting thoughts\"), mdx(\"p\", null, \"JAMstack, like most great technological trends, is a pretty awesome solution with a crummy name. It\\u2019s not a perfect solution by any stretch, but it empowers front-end developers to build all kinds of sites and applications using their exisiting skills.\"), mdx(\"p\", null, \"So what are you waiting for? Get out there and build something!\"));\n}\nMDXContent.isMDXComponent = true;"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"slug":"/what-is-jamstack/","previous":{"id":"f8a5c0bf-9199-5b15-abc1-c1c505cd4750","fields":{"slug":"/the-problem-with-context/"},"frontmatter":{"title":"The Problem with React's Context API"},"body":"function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"The Problem with React's Context API\",\n  \"date\": \"2019-11-28T12:00:00-0400\"\n};\n\nvar makeShortcode = function makeShortcode(name) {\n  return function MDXDefaultShortcode(props) {\n    console.warn(\"Component \" + name + \" was not imported, exported, or provided by MDXProvider as global scope\");\n    return mdx(\"div\", props);\n  };\n};\n\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, [\"components\"]);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"590px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/blog/static/e32a85ecdd68cc08c7896513261f347b/c35de/gorilla.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": [\"noopener\"]\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"66.66666666666666%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"A Gorilla looking thoughtful by Rob Schreckhise\",\n    \"title\": \"A Gorilla looking thoughtful by Rob Schreckhise\",\n    \"src\": \"/blog/static/e32a85ecdd68cc08c7896513261f347b/c739e/gorilla.jpg\",\n    \"srcSet\": [\"/blog/static/e32a85ecdd68cc08c7896513261f347b/8ee9c/gorilla.jpg 148w\", \"/blog/static/e32a85ecdd68cc08c7896513261f347b/ebbe7/gorilla.jpg 295w\", \"/blog/static/e32a85ecdd68cc08c7896513261f347b/c739e/gorilla.jpg 590w\", \"/blog/static/e32a85ecdd68cc08c7896513261f347b/5413e/gorilla.jpg 885w\", \"/blog/static/e32a85ecdd68cc08c7896513261f347b/4efde/gorilla.jpg 1180w\", \"/blog/static/e32a85ecdd68cc08c7896513261f347b/c35de/gorilla.jpg 1200w\"],\n    \"sizes\": \"(max-width: 590px) 100vw, 590px\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"React\\u2019s context API is awesome. As someone that looked at Redux as a junior developer and instantly felt defeated, learning about context was a relief. I used it in my apps, quickly forgot about Redux, and never looked back.\"), mdx(\"p\", null, \"That is, until I heard about the supposed performance problems with the Context API. Now, the big names in the React community will tell you not to worry about performance unless you start seeing issues. And yet, I keep hearing about context problems from other developers. One fellow even mentioned his boss banning the use of Context on their project.\"), mdx(\"p\", null, \"Let\\u2019s review the Context API in case you\\u2019re unfamiliar before we talk about its problems.\"), mdx(\"h2\", null, \"Why use the context API?\"), mdx(\"p\", null, \"The Context API is useful for sharing state between components that you can\\u2019t easily share with props. Here\\u2019s an example of a button component that needs to set the state of a distant ancestor:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"react-live use-render\",\n    \"react-live\": true,\n    \"use-render\": true\n  }), \"const { useState } = React\\n\\nfunction CountDisplay({ count }) {\\n  return <h2>The Count is: {count}</h2>\\n}\\n\\nfunction CountButton({ setCount }) {\\n  return (\\n    <button onClick={() => setCount(count => count + 1)}>\\n      Increment\\n    </button>\\n  )\\n}\\n\\nconst OuterWrapper = ({setCount}) => <InnerWrapper setCount={setCount}/>\\nconst InnerWrapper = ({setCount}) => <CountButton setCount={setCount}/>\\n\\nfunction App() {\\n  const [count, setCount] = useState(0)\\n  return (\\n    <div>\\n      <CountDisplay count={count} />\\n      <OuterWrapper setCount={setCount}/>\\n    </div>\\n  )\\n}\\n\\nrender(App)\\n\")), mdx(\"p\", null, \"The button component is within a few other components further down the tree, but still needs to access state from higher up in the app. So we have to pass \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"setCount\"), \" down to each component to finally get it to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CountButton\"), \" component. This is affectionately known as \\u201Cprop-drilling\\u201D, and used to be a huge pain point in React.\"), mdx(\"p\", null, \"The Context API makes short work of situations like this, thankfully.\"), mdx(\"h2\", null, \"How to use the Context API\"), mdx(\"p\", null, \"Kent C. Dodds has a fantastic \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kentcdodds.com/blog/application-state-management-with-react\"\n  }), \"blog post\"), \" that I refer to whenever I implement the Context API. If you don\\u2019t have time to read that, here\\u2019s the short version: Context is a way to share state between unrelated or distant components. All you have to do is wrap your components in a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Context.Provider\"), \" and then call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useContext(Context)\"), \" inside that component to access your state and helper functions.\"), mdx(\"p\", null, \"Here\\u2019s our counter example with context:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"react-live use-render\",\n    \"react-live\": true,\n    \"use-render\": true\n  }), \"const {useContext, useState, createContext} = React\\n\\nconst AppContext = createContext()\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const value = { count, setCount }\\n  return (\\n    <AppContext.Provider value={value}>\\n      {props.children}\\n    </AppContext.Provider>\\n  )\\n}\\n\\nfunction CountDisplay() {\\n  const { count } = useContext(AppContext)\\n  return <h2>The Count is: {count}</h2>\\n}\\n\\nfunction CountButton() {\\n  const { setCount } = useContext(AppContext)\\n  return (\\n    <button onClick={() => setCount(count => count + 1)}>\\n      Increment\\n    </button>\\n  )\\n}\\n\\nconst OuterWrapper = () => <InnerWrapper />\\n\\nconst InnerWrapper = () => <CountButton />\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <CountDisplay/>\\n        <OuterWrapper/>\\n      </AppProvider>\\n    </div>\\n  )\\n}\\n\\nrender(App)\\n\")), mdx(\"p\", null, \"Here we have \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CountDisplay\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CountButton\"), \" components that both need to interact with the higher-level \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" state in our context. We start by making a context with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createContext\"), \", then a provider component in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"AppProvider\"), \" to wrap our dependent components, and finally call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useContext\"), \" in each component to pull out the values we need. It doesn\\u2019t matter how far apart the components are as long as they\\u2019re wrapped in a provider.\"), mdx(\"p\", null, \"Pretty great right?\"), mdx(\"h2\", null, \"Kent C. Dodd\\u2019s Optimizations \\uD83D\\uDCC8\"), mdx(\"p\", null, \"We can improve on this a little bit by implementing some stuff that Kent has in his article on state management. Let\\u2019s take a look:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"react-live use-render\",\n    \"react-live\": true,\n    \"use-render\": true\n  }), \"const {useContext, useState, createContext, useMemo} = React\\nconst AppContext = createContext()\\n\\n// instead of calling useContext directly in our components,\\n// we make our own hook that throws an error if we try to\\n// access context outside of the provider\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context)\\n    throw new Error('AppContext must be used with AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  // here we use useMemo for... reasons.\\n  // this says don't give back a new count/setCount unless count changes\\n  const value = useMemo(() => ({ count, setCount }), [count])\\n  return <AppContext.Provider value={value} {...props} />\\n}\\n\\nfunction CountDisplay() {\\n  const { count } = useAppContext()\\n  return <h2>The Count is: {count}</h2>\\n}\\n\\nfunction CountButton() {\\n  const { setCount } = useAppContext()\\n  return (\\n    <button onClick={() => setCount(count => count + 1)}>\\n      Increment\\n    </button>\\n  )\\n}\\n\\nconst OuterWrapper = () => <InnerWrapper />\\n\\nconst InnerWrapper = () => <CountButton />\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <CountDisplay />\\n        <OuterWrapper />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\n\\nrender(App)\\n\")), mdx(\"p\", null, \"The first thing we do is throw an error if we try to access the context outside of our provider. This is a great idea to improve the developer experience of your app (aka: make the console scream at you when you forget how context works).\"), mdx(\"p\", null, \"The second thing is to memoize our context value to only re-render if the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" changes. Now, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \" is a difficult thing to wrap your head around, but the basic gist is that when you memoize something, you\\u2019re saying that you won\\u2019t return that value again unless your specified value changes. Kent has a \", mdx(\"a\", _extends({\n    parentName: \"p\"\n  }, {\n    \"href\": \"https://kentcdodds.com/blog/usememo-and-usecallback\"\n  }), \"great article\"), \" on that too if you want to read more.\"), mdx(\"p\", null, \"I can\\u2019t discern a difference between using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \" and not using it, but I would venture that if you\\u2019re doing some heavy lifting in your Context Provider, it might be beneficial to apply memoization. If you read Kent\\u2019s article on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useCallback\"), \" he cautions against using them unless you start to see performance hits. (Full Disclosure: I\\u2019ve never needed to use either one.)\"), mdx(\"p\", null, \"Kent also spreads his \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props\"), \" on the provider instead of using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"props.children\"), \", which is a neat trick, so I included that as well.\"), mdx(\"h2\", null, \"The Context API\\u2019s Dirty Little Secret \\uD83E\\uDD2B\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"590px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/c35de/trashman.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": [\"noopener\"]\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"100%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Man making the shush gesture with his finger over his lip, laying on a mound of trash. Photo by Jordan Beltran\",\n    \"title\": \"Man making the shush gesture with his finger over his lip, laying on a mound of trash. Photo by Jordan Beltran\",\n    \"src\": \"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/c739e/trashman.jpg\",\n    \"srcSet\": [\"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/8ee9c/trashman.jpg 148w\", \"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/ebbe7/trashman.jpg 295w\", \"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/c739e/trashman.jpg 590w\", \"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/5413e/trashman.jpg 885w\", \"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/4efde/trashman.jpg 1180w\", \"/blog/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/c35de/trashman.jpg 1200w\"],\n    \"sizes\": \"(max-width: 590px) 100vw, 590px\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"Boy, the Context API sure is great. It\\u2019s super easy to use compared to Redux and requires a lot less code, so why \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"wouldn\\u2019t\"), \" you use it?\"), mdx(\"p\", null, \"The problem with context is simple: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Everything that consumes a context re-renders everytime that context\\u2019s state changes.\")), mdx(\"p\", null, \"That means that if you\\u2019re consuming your context all over the place in your app, or worse, using one context for your entire app\\u2019s state, you\\u2019re causing a ton of re-renders all over the place!\"), mdx(\"p\", null, \"Let\\u2019s visualize this with a simple app. Let\\u2019s make a context with a counter and a message. The message will never change, but be consumed by three components that display the message in a random color on each render. The count will be consumed by one component, and be the only value that changes.\"), mdx(\"p\", null, \"That sounds like a middle school math problem, but if you look at this code and the resulting app, the problem becomes blatantly obvious:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"react-live use-render\",\n    \"react-live\": true,\n    \"use-render\": true\n  }), \"const {useContext, useState, createContext} = React\\nconst AppContext = createContext()\\n\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context)\\n    throw new Error('useAppContext must be used within AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  // the count for our counter component\\n  const [count, setCount] = useState(0)\\n  // this message never changes!\\n  const [message, setMessage] = useState('Hello from Context!')\\n  const value = {\\n    count,\\n    setCount,\\n    message,\\n    setMessage\\n  }\\n  return <AppContext.Provider value={value} {...props}/>\\n}\\n\\nfunction Message() {\\n  const { message } = useAppContext()\\n  // the text will render to a random color for\\n  // each instance of the Message component\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useAppContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <h2>Re-renders! \\uD83D\\uDE29</h2>\\n        <Message />\\n        <Message />\\n        <Message />\\n        <Count />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), mdx(\"p\", null, \"Everything re-renders when we click increment \\uD83D\\uDE31.\"), mdx(\"p\", null, \"The message components don\\u2019t even use the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" from our context, but they re-render anyway. Yikes!\"), mdx(\"h3\", null, \"What about memoization?\"), mdx(\"p\", null, \"Maybe we just forgot to use \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \" like Kent did in his example. Let\\u2019s memoize our context and see what happens:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"react-live use-render\",\n    \"react-live\": true,\n    \"use-render\": true\n  }), \"const {useContext, useState, createContext, useMemo} = React\\nconst AppContext = createContext()\\n\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context) throw new Error('useAppContext must be used within AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const [message, setMessage] = useState('Hello from Context!')\\n  // here we pass our value to useMemo,\\n  // and tell useMemo to only give us new values\\n  // when count or message change\\n  const value = useMemo(() => ({\\n    count,\\n    setCount,\\n    message,\\n    setMessage\\n  }), [count, message])\\n  return <AppContext.Provider value={value} {...props}/>\\n}\\n\\nfunction Message() {\\n  const { message } = useAppContext()\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useAppContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <h2>Re-renders! \\uD83D\\uDE29</h2>\\n        <Message />\\n        <Message />\\n        <Message />\\n        <Count />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), mdx(\"p\", null, \"Nope! Memoization with \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"useMemo\"), \" doesn\\u2019t help at all!\"), mdx(\"h3\", null, \"What about components that don\\u2019t consume Context, do they re-render?\"), mdx(\"p\", null, \"That\\u2019s an excellent question, let\\u2019s test it with a Message component that doesn\\u2019t consume context:\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"react-live use-render\",\n    \"react-live\": true,\n    \"use-render\": true\n  }), \"const {useContext, useState, createContext, useMemo} = React\\nconst AppContext = createContext()\\n\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context) throw new Error('useAppContext must be used within AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const [message, setMessage] = useState('Hello from Context!')\\n  const value = useMemo(() => ({\\n    count,\\n    setCount,\\n    message,\\n    setMessage\\n  }), [count, message])\\n  return <AppContext.Provider value={value} {...props}/>\\n}\\n\\n// this component does NOT consume the context\\n// but is still within the Provider component\\nfunction IndependentMessage() {\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>I'm my own Independent Message!</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Message() {\\n  const { message } = useAppContext()\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useAppContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <h2>Re-renders! \\uD83D\\uDE29</h2>\\n        <Message />\\n        <Message />\\n        <Message />\\n        <IndependentMessage />\\n        <Count />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), mdx(\"p\", null, \"Well, this is the only good news so far. \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Only components that call \", mdx(\"inlineCode\", {\n    parentName: \"strong\"\n  }, \"useContext\"), \" re-render whenever the context\\u2019s state changes.\")), mdx(\"p\", null, \"Still, this is bad news for our app. We don\\u2019t want to trigger a bunch of unnecessary re-renders everywhere we use a context.\"), mdx(\"p\", null, \"Imagine if those message components were doing a lot of work like calculating animations, or if we had a huge React app with lots of components dependent on our context. That could lead to pretty serious performance issues, right?\"), mdx(\"h2\", null, \"Should we stop using Context?\"), mdx(\"p\", null, mdx(\"span\", _extends({\n    parentName: \"p\"\n  }, {\n    \"className\": \"gatsby-resp-image-wrapper\",\n    \"style\": {\n      \"position\": \"relative\",\n      \"display\": \"block\",\n      \"marginLeft\": \"auto\",\n      \"marginRight\": \"auto\",\n      \"maxWidth\": \"590px\"\n    }\n  }), \"\\n      \", mdx(\"a\", _extends({\n    parentName: \"span\"\n  }, {\n    \"className\": \"gatsby-resp-image-link\",\n    \"href\": \"/blog/static/8c27d995b617560da5b04f46a8069006/c35de/trash.jpg\",\n    \"style\": {\n      \"display\": \"block\"\n    },\n    \"target\": \"_blank\",\n    \"rel\": [\"noopener\"]\n  }), \"\\n    \", mdx(\"span\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-background-image\",\n    \"style\": {\n      \"paddingBottom\": \"75%\",\n      \"position\": \"relative\",\n      \"bottom\": \"0px\",\n      \"left\": \"0px\",\n      \"backgroundSize\": \"cover\",\n      \"display\": \"block\"\n    }\n  })), \"\\n  \", mdx(\"img\", _extends({\n    parentName: \"a\"\n  }, {\n    \"className\": \"gatsby-resp-image-image\",\n    \"alt\": \"Sign showing man throwing away trash, photo by Gary Chan\",\n    \"title\": \"Sign showing man throwing away trash, photo by Gary Chan\",\n    \"src\": \"/blog/static/8c27d995b617560da5b04f46a8069006/c739e/trash.jpg\",\n    \"srcSet\": [\"/blog/static/8c27d995b617560da5b04f46a8069006/8ee9c/trash.jpg 148w\", \"/blog/static/8c27d995b617560da5b04f46a8069006/ebbe7/trash.jpg 295w\", \"/blog/static/8c27d995b617560da5b04f46a8069006/c739e/trash.jpg 590w\", \"/blog/static/8c27d995b617560da5b04f46a8069006/5413e/trash.jpg 885w\", \"/blog/static/8c27d995b617560da5b04f46a8069006/4efde/trash.jpg 1180w\", \"/blog/static/8c27d995b617560da5b04f46a8069006/c35de/trash.jpg 1200w\"],\n    \"sizes\": \"(max-width: 590px) 100vw, 590px\"\n  })), \"\\n  \"), \"\\n    \")), mdx(\"p\", null, \"I\\u2019ll go ahead and say this now: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"no, this isn\\u2019t a reason to stop using context\"), \". There\\u2019s a ton of apps out there using context and chugging along just fine, including a bunch of my own apps.\"), mdx(\"p\", null, \"Still, performance is kind of a big deal. I don\\u2019t want to leave you sitting up at night worrying about the Context API\\u2019s dirty little secret. So let\\u2019s talk about some ways to deal with this re-render business.\"), mdx(\"h3\", null, \"Option 1: Don\\u2019t worry at all. Keep on Context\\u2019n like you do. YOLO \\uD83E\\uDD2A!\"), mdx(\"p\", null, \"I\\u2019ve basically used Context a whole bunch in a lot of various apps without memoization, at the top level of my app, and consumed by a bunch of components without noticing any performance hits at all. Like I said before, a lot of the React folks say you shouldn\\u2019t even worry about performance optimizations until you see performance impacts.\"), mdx(\"p\", null, \"Still, this strategy won\\u2019t work for everyone. You may already have performance issues in your app, or if your app processes a lot of logic or animations, you may see performance issues as your app grows and end up doing some serious refactoring down the road.\"), mdx(\"h3\", null, \"Option 2: Use Redux or Mobx\"), mdx(\"p\", null, \"Redux and Mobx both use the context API, so how do they help? The store that\\u2019s shared by these state management libraries with context is a little different from sharing state directly with context. When you\\u2019re using Redux and Mobx, there\\u2019s a diffing algorithm at work that makes sure to only re-render the components that actually need to re-render.\"), mdx(\"p\", null, \"Still, context was supposed to save us from having to learn Redux and Mobx! There\\u2019s a lot of abstractions and boilerplate involved in using a state management library, making it an unattractive solution to some folks.\"), mdx(\"p\", null, \"Plus, isn\\u2019t keeping all of our state in global state a bad practice?\"), mdx(\"h3\", null, \"Option 3: Use Multiple Contexts, and keep state close to its Dependent Components\"), mdx(\"p\", null, \"This solution takes the most finesse to pull off, but gives you the best performance without reaching for Redux and Mobx. It relies on being smart about your state management choices, and only passing state up to a context if you need to share it between distant components.\"), mdx(\"p\", null, \"There\\u2019s a few key tenants to this strategy:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"Let a component manage its own state if it can.\"), \" This is a good practice to follow regardless of your choice of state management. For example, if you have a modal that needs to keep track of an open/closed state, but no other components need to know if that modal is open, keep that open/closed state in the modal. Don\\u2019t push state into context (or Redux) if you don\\u2019t have to!\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"If your state is shared between a parent and a few children, just prop it down.\"), \" This is the old school method of sharing state. Just pass it as props to the children components that need it. Passing props or \\u201CProp-drilling\\u201D can be miserable with deeply nested components, but if you\\u2019re only passing things down a few levels, you should probably just do it.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"If the previous two things fail, use context but keep it close to the components that depend on it.\"), \" This means if you need to share some state, like a form for instance with multiple components, go ahead and make a separate context for just the form and wrap the form components in your provider.\")), mdx(\"p\", null, \"That last one deserves an example. Let\\u2019s apply it to our problem app from before. We can fix those re-renders by separating the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"message\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" into their own contexts.\"), mdx(\"pre\", null, mdx(\"code\", _extends({\n    parentName: \"pre\"\n  }, {\n    \"className\": \"language-jsx\",\n    \"metastring\": \"react-live use-render\",\n    \"react-live\": true,\n    \"use-render\": true\n  }), \"const { useContext, useState, createContext } = React\\nconst CountContext = createContext()\\n\\n// Now count context only worries about count!\\nfunction useCountContext() {\\n  const context = useContext(CountContext)\\n  if (!context)\\n    throw new Error('useCountContext must be used within CountProvider!')\\n  return context\\n}\\n\\nfunction CountProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const value = { count, setCount }\\n  return <CountContext.Provider value={value} {...props}/>\\n}\\n\\n// And message context only worries about message!\\nconst MessageContext = createContext()\\n\\nfunction useMessageContext() {\\n  const context = useContext(MessageContext)\\n  if (!context)\\n    throw new Error('useMessageContext must be used within MessageProvider!')\\n  return context\\n}\\n\\nfunction MessageProvider(props) {\\n  const [message, setMessage] = useState('Hello from Context!')\\n  const value = { message, setMessage }\\n  return <MessageContext.Provider value={value} {...props}/>\\n}\\n\\nfunction Message() {\\n  const { message } = useMessageContext()\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useCountContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <h2>No Unnecessary Re-renders! \\uD83D\\uDE0E</h2>\\n      <MessageProvider>\\n        <Message />\\n        <Message />\\n        <Message />\\n      </MessageProvider>\\n      <CountProvider>\\n        <Count />\\n      </CountProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), mdx(\"p\", null, \"Now our state is only shared with the components that care about that state. When we increment, the colors of our message components stay the same because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"count\"), \" lives outside of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"messageContext\"), \".\"), mdx(\"h2\", null, \"Final Thoughts\"), mdx(\"p\", null, \"Although this article\\u2019s title is a little incendiary and the \\u201Cproblem\\u201D with context  may not be the boogie man some might envision it to be, I still think this is worth talking about. React\\u2019s flexibility makes it both a great framework for beginners as well as a devastating footgun for those that don\\u2019t know its inner-workings. I don\\u2019t forsee a lot of people tripping over this particular detail, but if you\\u2019re using context and seeing performance issues, it\\u2019s a good thing to know!\"));\n}\nMDXContent.isMDXComponent = true;"},"next":null}}}