{"componentChunkName":"component---src-templates-blog-post-js-content-file-path-home-lee-dev-side-projects-blog-content-blog-why-write-tests-index-md","path":"/why-write-tests/","result":{"data":{"site":{"siteMetadata":{"title":"Strings and Things","author":"Lee Warrick","siteUrl":"https://leewarrick.com/blog"}},"mdx":{"id":"a4706fed-f972-5ca1-aafa-e496f84b7a9c","excerpt":"Testing is a subject that nearly every tutorial and course tends to gracefully skip over. This is tragic because as soon as you enter the workforce as a developer, you’re going to…","frontmatter":{"title":"What's the point of tests?","date":"April 03, 2022"},"body":"\n![Picture of a multimeter testing circuits. Photo by Nicolas Thomas https://unsplash.com/photos/3GZi6OpSDcY](./multimeter.jpg)\n\nTesting is a subject that nearly every tutorial and course tends to gracefully skip over. This is tragic because as soon as you enter the workforce as a developer, you're going to be expected to write tests. You may even find yourself writing more tests than code. Too many new developers (myself included), walk into their first job blind to testing principles and practices. More than a few develop negative opinions of testing, and some even learn to resent it. \n\nTests are not a necessary evil. In fact, I've found a lot of comfort in well-written automated tests as I've progressed in my career. With that said, let's discuss some benefits of tests.\n\n```js js-live autorun no-code scripts=\"mocha!https://cdnjs.cloudflare.com/ajax/libs/mocha/8.0.1/mocha.min.js,chai!https://cdnjs.cloudflare.com/ajax/libs/chai/4.2.0/chai.min.js,sinon!https://cdnjs.cloudflare.com/ajax/libs/sinon.js/9.0.2/sinon.min.js\"\nconst {\n  EVENT_RUN_BEGIN,\n  EVENT_RUN_END,\n  EVENT_TEST_FAIL,\n  EVENT_TEST_PASS,\n  EVENT_SUITE_BEGIN,\n  EVENT_SUITE_END\n} = Mocha.Runner.constants;\n\nmocha.setup({\n  ui: \"bdd\",\n  reporter: function(runner) {\n    let currentSuite\n    let currentParent\n    let indent = 0\n    runner.once(EVENT_RUN_BEGIN, () => {\n    })\n    runner.on(EVENT_SUITE_BEGIN, (suite) => {\n    })\n    runner.on(EVENT_SUITE_END, (suite) => {\n      if (suite.root) return\n       indent = indent - 2 < 0 ? 0 : indent - 2\n    })\n    runner.on(EVENT_TEST_PASS, (test) => {\n      if (currentParent !== test.parent.parent.title) {\n        currentParent = test.parent.parent.title\n        if (currentParent) {\n          console.log(`${\" \".repeat(indent)}${currentParent}`)\n          indent += 2\n        }\n      }\n      if (currentSuite !== test.parent.title) {\n        currentSuite = test.parent.title\n        console.log(`${\" \".repeat(indent)}${currentSuite}`)\n        indent += 2\n      }\n\n      console.log(`${\" \".repeat(indent)}🟢 ${test.title}`)\n    });\n    runner.on(EVENT_TEST_FAIL, (test) => {\n      if (currentParent !== test.parent.parent.title) {\n        currentParent = test.parent.parent.title\n        if (currentParent) {\n          console.log(`${\" \".repeat(indent)}${currentParent}`)\n          indent += 2\n        }\n      }\n      if (currentSuite !== test.parent.title) {\n        currentSuite = test.parent.title\n        console.log(`${\" \".repeat(indent)}${currentSuite}`)\n        indent += 2\n      }\n\n      console.log(`${\" \".repeat(indent)}❌ ${test.title}`)\n    });\n    runner.once(EVENT_RUN_END, () => {\n      indent = 0\n      console.log(`${runner.stats.passes}/${runner.stats.passes + runner.stats.failures} tests passing`);\n    });\n  },\n  cleanReferencesAfterRun: true\n})\nwindow.assert = chai.assert;\nwindow.expect = chai.expect;\nwindow.mochaRun = mocha.run\nmocha.run = function() {\n  mocha.unloadFiles()\n  window.mochaRun()\n}\n```\n\n## Tests make maintaining and refactoring code much easier\n\nLet's say for example that you had a function that checks to see if a word is a palindrome (it's the same backwards and forwards):\n\n```js \nfunction isPalindrome(str) {\n  str = str.toLowerCase()\n  let strNoPunc = \"\"\n  const letters = 'abcdefghijklmnopqrstuvwxyz'.split(\"\")\n  for(var i = 0; i < str.length; i++) {\n    if(letters.indexOf(str[i]) > -1) strNoPunc += str[i]\n  }\n  let reversed = \"\"\n  for (var i = strNoPunc.length - 1; i >= 0; i--) {\n    reversed += strNoPunc[i]\n  }\n  return reversed === strNoPunc\n}\n```\nYou haven't written a for loop since you first learned JavaScript, so it takes you a second to read through and see what's happening in the function. It's been humming along in your codebase for quite some time before you came across it, but you know you could write a more readable version. How do you proceed, though?\n\nOne way is to manually test with `console.log`:\n\n```js js-live autorun\nfunction isPalindrome(str) {\n  str = str.toLowerCase()\n  let strNoPunc = \"\"\n  const letters = 'abcdefghijklmnopqrstuvwxyz'.split(\"\")\n  for(var i = 0; i < str.length; i++) {\n    if(letters.indexOf(str[i]) > -1) strNoPunc += str[i]\n  }\n  let reversed = \"\"\n  for (var i = strNoPunc.length - 1; i >= 0; i--) {\n    reversed += strNoPunc[i]\n  }\n  return reversed === strNoPunc\n}\nconsole.log(isPalindrome('radar'))\nconsole.log(isPalindrome('pasta'))\nconsole.log(isPalindrome('radar!'))\n```\nApparently `isPalindrome` returns a boolean and is able to handle special characters. But what about spaces? What about uppercase letters? Does it handle numbers? More importantly, _which one of those cases are important in your codebase?_\n\nThat's the rub when it comes to refactoring this function. You know more or less what the function does, but what about all the edge cases? What if it's fed a non-string? Does it return a boolean or throw an error? Does that matter for your existing code that's using `isPalindrome`?\n\nIn an ideal world, you'd have some well-written tests that outline the edge cases of your function. Test cases should cover the functionalities and behaviors of your code that are critical for the final product. Try rewriting the function below and running the tests to see if you can do better.\n\n```js js-live scripts=\"mocha,chai\"\nfunction isPalindrome(str) {\n  str = str.toLowerCase()\n  let strNoPunc = \"\"\n  const letters = 'abcdefghijklmnopqrstuvwxyz'.split(\"\")\n  for(var i = 0; i < str.length; i++) {\n    if(letters.indexOf(str[i]) > -1) strNoPunc += str[i]\n  }\n  let reversed = \"\"\n  for (var i = strNoPunc.length - 1; i >= 0; i--) {\n    reversed += strNoPunc[i]\n  }\n  return reversed === strNoPunc\n}\n\ndescribe('isPalindrome', function() {\n  it('should return a boolean', function() {\n    expect(typeof isPalindrome('banana')).to.eq('boolean')\n  })\n  it('should return true for a palindrome', function() {\n    expect(isPalindrome('radar')).to.be.true\n  })\n  it('should return false for non-palindromes', function() {\n    expect(isPalindrome('banana')).to.be.false\n  })\n  it('should ignore special characters', function() {\n    expect(isPalindrome('radar!')).to.be.true\n  })\n  it('should ignore spaces', function() {\n    expect(isPalindrome('my gym')).to.be.true\n  })\n  it('should ignore letter casing', function() {\n    expect(isPalindrome('Eva, can I see bees in a cave?')).to.be.true\n  })\n})\n\nmocha.run()\n```\n\nWere you able to get all the test cases to pass?\n\nDid you write something like the following? If you didn't, can you see what the solution below is missing? Try and add the missing code using the test cases:\n\n```js js-live scripts=\"mocha,chai\"\nfunction isPalindrome(str) {\n  return str === str.split(\"\").reverse().join(\"\")\n}\n\ndescribe('isPalindrome', function() {\n  it('should return a boolean', function() {\n    expect(typeof isPalindrome('banana')).to.eq('boolean')\n  })\n  it('should return true for a palindrome', function() {\n    expect(isPalindrome('radar')).to.be.true\n  })\n  it('should return false for non-palindromes', function() {\n    expect(isPalindrome('banana')).to.be.false\n  })\n  it('should ignore special characters', function() {\n    expect(isPalindrome('radar!')).to.be.true\n  })\n  it('should ignore spaces', function() {\n    expect(isPalindrome('my gym')).to.be.true\n  })\n  it('should ignore letter casing', function() {\n    expect(isPalindrome('Eva, can I see bees in a cave?')).to.be.true\n  })\n})\n\nmocha.run()\n```\n\nIn the code above, we solved the main palindrome problem, but failed to handle special characters, casing, and spaces. Here's the code with solutions for all the tests:\n\n```js js-live scripts=\"mocha,chai\"\nfunction isPalindrome(str) {\n  str = str.toLowerCase().replaceAll(/[^a-z]/g, \"\")\n  return str === str.split(\"\").reverse().join(\"\")\n}\n\ndescribe('isPalindrome', function() {\n  it('should return a boolean', function() {\n    expect(typeof isPalindrome('banana')).to.eq('boolean')\n  })\n  it('should return true for a palindrome', function() {\n    expect(isPalindrome('radar')).to.be.true\n  })\n  it('should return false for non-palindromes', function() {\n    expect(isPalindrome('banana')).to.be.false\n  })\n  it('should ignore special characters', function() {\n    expect(isPalindrome('radar!')).to.be.true\n  })\n  it('should ignore spaces', function() {\n    expect(isPalindrome('my gym')).to.be.true\n  })\n  it('should ignore letter casing', function() {\n    expect(isPalindrome('Eva, can I see bees in a cave?')).to.be.true\n  })\n})\n\nmocha.run()\n```\n\nThis is a small example in isolation, but imagine your code base has many functions like this that are all interconnected in your project. Assuming your tests are up to date, you can hopefully imagine the peace of mind you get from having tests to double-check your code whenever you need to refactor it in the future.\n\n## Tests can be great documentation\n\nDocumentation is a perennial pain for most developers. It's so difficult to keep improving software as well as keeping its documentation up to date because essentially the two are related but disconnected. What if you had documentation that read itself and told you when your code and docs were out of sync?\n\nGood news! That's basically what well-written tests do. Let's look at the case titles from the previous section:\n\n```\nshould return a boolean\nshould return true for a palindrome\nshould return false for non-palindromes\nshould ignore special characters\nshould ignore spaces\nshould ignore letter casing\n```\n\nWell-written tests can be a great reference for understanding how a piece of code works without having to step through the implementation. Looking at the test cases above, you're able to learn a lot about the function in question without even looking at the function's code.\n\nNot only do these tests tell the developer _exactly_ how the function is supposed to behave, when you run the tests they **enforce** those rules as well. Including automation that runs these tests before deploys provides a pretty powerful system to prevent breaking the project when refactoring or introducing new features.\n\n## Tests force us to reflect on implementation\n\nTesting forces us to think about our code beyond how it solves our immediate problem. Naturally that means thinking of aforementioned edge cases, but it also makes us think about the how the program itself is constructed.\n\nLet's say we were working on a calculator application. We're implementing an add function for our app, and so we write it to take two numbers, and output them to the paragraph tag below:\n\n```html html-live no-edit\n<h3>Calculator Output: <span id=\"output\"></span></h3>\n```\n\n```js js-live autorun\nfunction add(num1, num2) {\n  const sum = num1 + num2\n  document.getElementById('output').textContent = sum\n}\n\nadd(2, 3)\n```\n\nAll done, right? Well, let's say we now want to write a test for our add function. Unlike `isPalindrome` above, `add` doesn't just return its output, it sends it to the DOM. Our `add` function has a side effect: it depends on certain HTML elements to exist to function properly. To write our test, we have to either stub `getElementById` and monitor it to make sure it's being passed the correct input, or access the `#output` element to check its text. \n\nWe could do those things, but do we really need to test that `getElementById` is implemented correctly? I'd argue that the engineers at Google and Mozilla are very capable of maintaining this JS feature without us needing to test it. What we really need to know is if we're adding correctly.\n\nWith that in mind, it might make more sense to split our function into two and separate the DOM manipulation from the calculation. \n\n```js js-live scripts=\"mocha,chai\"\nfunction add(num1, num2) {\n  return num1 + num2\n}\nfunction updateOutput(value) {\n  document.getElementById('output').textContent = value\n}\n\ndescribe('add', () => {\n  it('should add two numbers', () => {\n    expect(add(2, 3)).to.eq(5)\n  })\n})\n\nmocha.run()\n```\n\nWe've isolated a side effect and made `add` a pure function without really thinking about the code from a functional standpoint. We refactored to make testing easier, but code that's easy to test is also more reusable and maintainable. Since this is a calculator app, we're likely to need to update the DOM in the same way for other operations like multiplication and division. We're also now free to use the add function in other places in the app as we see fit.\n\nEven though it's a bit silly to write a test for something like an addition operation, the exercise of thinking about the code and how to test it has guided us to a better solution. This is why it's often said that code that's hard to test is a \"code smell\". \n\n## Closing thoughts \n\nWriting tests is like writing documentation or learning Git: you don't appreciate it until you need it. Because tests don't directly contribute to the functionality of the product, they're often overlooked by teams looking to iterate quickly. You'd be hard-pressed to find good tutorials on tests or courses that bother to spend time teaching how to write them for the same reason.\n\nHowever, the nature of code is that it's temporary. There will always be revisions, refactors, or rewrites to any code that lives long enough to be deemed legacy. In each of those cases, well-written tests can make a huge difference when revisiting old code.\n\nSadly, I didn't actually encounter testing in a meaningful way until I was already employed as a junior developer. When I tried to submit my first pull request at my first job, I had to go back and write tests not only for the code in my pull request, but for code other engineers had merged and left untested. I can tell you from experience that the last few days of your first sprint are not when you want to be learning how to write tests.\n\nYears later, I found myself writing tests to tame a project that was previously seen as an untenable monster of legacy code. Our team inherited the project and codebase from a prevous contractor, and therefore were behind the curve in understanding how everything worked. Good testing practices showed us how we could keep bugs from reaching production and brought a new level of confidence to our team despite our unfamiliar codebase.\n\nTesting is a big subject, but it's an important one. Give it the head space it deserves in your career. The codebase you save might just be your own.\n"}},"pageContext":{"slug":"/why-write-tests/","previous":{"id":"18345b29-0567-56d1-a0c6-fb08c242d85c","fields":{"slug":"/chmod-and-permissions/"},"frontmatter":{"title":"Understanding Unix Permissions, chmod, and ls -la"},"body":"\n![A picture of a train terminal in Japan by Andrew Leu (https://unsplash.com/photos/fWZ1-EEYzPM). This article is not about this kind of terminal.](./terminal.jpg)\n\n_Whoa! Lee, Why are you writing about terminal commands? I thought this was a front-end blog?_\n\nListen. I contain multitudes. Plus, you're gonna run across a permissions issue at some point regardless of where you hang out in the stack, so why not learn a little about what's going on here?\n\nCool? Cool. Let's roll.\n\n## Why can't I run this script!?\n\nLet's say you're wanting to run a certain script on your computer. Maybe you downloaded it from somewhere or copied it over from stack overflow. Maybe you wrote your own script, who knows? Let's say you have a cool script like this one:\n\n```bash\n#!/bin/bash\n\necho \"Have a great day!\"\n```\n\nSo you jump into your terminal and run `./my-script.sh` and you're greeted with:\n\n```\n$ ./my-script.sh\npermission denied: ./my-script.sh\n```\n\nSo you jump onto stack overflow, search 'run script permission denied' or something, and you get a terse answer in the way of `chmod 744 <filename>`. So you copy that into your terminal and run it, not really worrying about the mysteries of Unix:\n\n```\n$ chmod 744 ./my-script.sh\n$ ./my-script.sh\nHave a nice day!\n```\n\nSatisfied, you go about your business, feeling appropriately greeted by your terminal.\n\nHowever, deep in the back of your subconscious, you've unknowingly unleashed a tiny code demon. This tiny demon waits until you're showering or about to fall asleep--basically when you're finally finding that peaceful zen state that's so hard to channel--and it whispers a question into your brain: _\"What does that command do?\"_\n\nFor a moment, you wonder why you're not more familiar with Unix, doubt yourself and your abilities, and then pack those feelings back down into pandora's box and go about your day.\n\n## Where did my dotfiles go?\n\nIf you've been programming for a minute, you're probably worked with dotfiles. Maybe your project has a `.env` file for API keys, or maybe you colossally destroyed a git history and decided that obliterating the `.git` folder in your project is the last option you've got left.\n\nIn any case, you jump into your terminal and run your trusty `ls` command.\n\n```\n$ ls\nwork stuff morestuff not_file_you_want.js\n```\n\n_Fiddlesticks! Where's my file? It shows up in vscode, why isn't it here!?_\n\nOne more trip to stack overflow and you get `ls -la` as your green checked answer, which gives you this:\n\n```\n$ ls -la\ndrwxr-xr-x 15 you  you   4096 Apr 24 11:16 .\ndrwxr-xr-x  3 root root  4096 Mar 30 12:09 ..\n-rw-r--r--  1 you  you     38 Apr 24 11:04 .mydotfile\ndrwxr-xr-x  9 you  you   4096 Apr 16 09:50 work\ndrwxr-xr-x  9 you  you   4096 Apr 13 09:50 stuff\ndrwxr-xr-x  9 you  you   4096 Apr 11 09:50 morestuff\n-rw-r--r--  1 you  you     38 Apr 24 11:04 not_file_you_want.js\n```\n\nSuccess! There's my dot file that's appropriately named `.mydotfile`. But that little demon in your mind chimes in... \"_What are all those letters and dashes at the beginning?_\"\n\n_ARGH!_ Impostor syndrome! Doubt! Fear! **The dark side!**\n\nYou ask yourself, _Why am I so bad at using computers!?_\n\n## Learn Unix permissions and banish your doubt demons!\n\nLet's first talk about that weird little string of letters and dashes.\n\n```\n-rw-r--r--  1 you  you     38 Apr 24 11:04 .mydotfile\n```\n\nThat string of `-rw-r-r--r--` is a list of permissions for that file! More on the meaning of that in a second.\n\nThe other information from left to right is the number of links to that file (1), owner, group owner, file size (38), date/time last modified, and the file name.\n\nNow, what about that letter/dash nonsense?\n\n```\n-rw-r--r--\n```\n\nThis is actually a grouping of 4 subsets of information.\n\n```\ntype | owner | group | everyone else\n------------------------------------\n-    | rw-   | r--   | r--\n```\n\nFor the type, the dash signifies that this is just a regular ol' file. You'll see `d` to signify directories and `l` for links, and might even see different colors in your terminal to highlight those types of files.\n\nThe rest of the columns have three more bits of info, which are specific permissions for each subset of users on the system. 'Owner' is the creator of the file, 'group' is the group of users that owner belongs to, and the last section is every other user on the system.\n\nAs for the letters themselves, they signify (r)ead (w)rite and e(x)ecute. So for the example above we have:\n\n\n```\ntype | owner | group | everyone else\n------------------------------------\n-    | rw-   | r--   | r--\nfile | read/ | read  | read\n       write\n```\nThis means you (the owner) can read and write to the file, but other users can only read the file.\n\nHere's another set of permissions you'll often see on directories:\n\n```\ntype     | owner    | group    | everyone else\n------------------------------------------\nd        | rwx      | r-x      | r-x\ndirectory| read/    | read/    | read/\n           write/     execute    execute\n           execute\n```\n\nThis means you (again, the owner) can do it all, but others can read and `cd` into the directory.\n\n## Changing Permissions\n\nGreat! So now you know what all those crazy letters mean. But how about changing them?\n\nLet's look at our example directory from above when we ran `ls -la`:\n\n```\n$ ls -la\ndrwxr-xr-x 15 you  you   4096 Apr 24 11:16 .\ndrwxr-xr-x  3 root root  4096 Mar 30 12:09 ..\n-rw-r--r--  1 you  you     38 Apr 24 11:04 .mydotfile\ndrwxr-xr-x  9 you  you   4096 Apr 16 09:50 work\ndrwxr-xr-x  9 you  you   4096 Apr 13 09:50 stuff\ndrwxr-xr-x  9 you  you   4096 Apr 11 09:50 morestuff\n-rw-r--r--  1 you  you     38 Apr 24 11:04 not_file_you_want.js\n```\n\nLet's say we wanted to change the permissions of the `not_file_you_want.js` file and add execute permissions for the owner.\n\nTo do this, we'll use the `chmod` command:\n\n```\n$ chmod u+x not_file_you_want.js\n```\n\nHere the `u+x` part may trip you up, but take another look. It's saying (u)ser + e(x)ecute, or add execute permissions to the user.\n\nWhat about more granular permissions? What if we wanted to remove all permissions from any other users?\n\nWe can be ultra specific with `chmod`:\n\n```\n$ chmod u=rwx,g-rwx,o-rwx not_file_you_want.js\n```\n\nSo this command says (u)ser permissions should equal (r)ead, (w)rite, and e(x)ecute. Remove all permissions from the group, and remove all permissions from all other users.\n\n## Binary Shortcuts\n\n![A blue and grey sign with the number 2 on it. Photo by Sonny Ravesteijn (https://unsplash.com/photos/xyxjKdpUg4I)](./two.jpg)\n\nSo now you can explicitly set whatever file permissions you want. But that little brain demon might still be screaming about our first stack overflow answer.\n\n```\n$ chmod 744 ./my-script.sh\n```\n\nWhat the heck does 744 mean?\n\nThis is actually shorthand for `-rwxr--r--`. Each number represents a user subset. The first number (7) is user, the middle is group, and the last is all other users, just like we showed in our breakdown earlier: `rwx | r-- | r--`.\n\nEach number is actually a binary representation of the three permissions combined. Let's look at just the user permissions:\n\n```\n2^2     | 2^1     | 2^0\nread    | write   | execute\n---------------------------\n1       | 1       | 1\n```\n\nHere we're indicating we want all three permissions (rwx), so we add 2^2, 2^1, 2^0 together to get 7.\n\nFor the other groups:\n\n```\n2^2     | 2^1     | 2^0\nread    | write   | execute\n---------------------------\n1       | 0       | 0\n```\nWe only count 2^2 which is equal to 4 for the group and others permissions, which combined with our 7 gives us 744.\n\nHere's some other common permission examples:\n\n```\n777 = 111 111 111 = rwxrwxrwx\n666 = 110 110 110 = rw-rw-rw-\n644 = 110 100 100 = rw-r--r--\n600 = 110 000 000 = rw-------\n```\n\nPretty wild right?\n\nSo now when you see this command:\n\n```\n$ chmod 700 my-file.sh\n```\n\nYou know that means you're giving the user all permissions and removing all permissions from everyone else. Look at you go, you little Linux Guru 😎.\n\n## Parting Thoughts\n\nSpecial Thanks to my colleague Clay Benson for explaining this to me on a conference call. I have stared at those little strings of `rwx` for _years_ without bothering to look up what they signify, just chalking it up to terminal magic and resiging myself to ignorance. I was actually stunned at how logical the design of Unix file permissions actually is, and the byte math absolutely floored me when I learned it and inspired me to write this post.\n\nThe next time you do some stack overflow linux wizardry, do a little research and you might surprise yourself with how much you learn. I know I will.\n","internal":{"contentFilePath":"/home/lee/dev/side_projects/blog/content/blog/chmod-and-permissions/index.md"}},"next":null,"frontmatter":{"title":"What's the point of tests?","date":"2022-04-03T12:00:00-0400"}}},"staticQueryHashes":["2836739900","4250957540"],"slicesMap":{}}