"use strict";(self.webpackChunkblog=self.webpackChunkblog||[]).push([[629],{814:function(e,t,n){n.r(t),n.d(t,{default:function(){return p}});var a=n(1151),l=n(7294);function o(e){const t=Object.assign({div:"div",p:"p",a:"a",em:"em",h2:"h2",code:"code",pre:"pre",strong:"strong",h3:"h3"},(0,a.ah)(),e.components);return l.createElement(l.Fragment,null,l.createElement(t.div,{dangerouslySetInnerHTML:{__html:'<span\n      class="gatsby-resp-image-wrapper"\n      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; "\n    >\n      <a\n    class="gatsby-resp-image-link"\n    href="/blog/static/91985b102e11e1a9b8ac2de71cb5733e/e5166/typewriter.jpg"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n    <span\n    class="gatsby-resp-image-background-image"\n    style="padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEA//EABYBAQEBAAAAAAAAAAAAAAAAAAIAAf/aAAwDAQACEAMQAAABwVpiqC8s/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAAxITIv/aAAgBAQABBQJiZ6jZVrjshZXzx//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABYRAQEBAAAAAAAAAAAAAAAAAAABEf/aAAgBAgEBPwFsf//EAB4QAQABAgcAAAAAAAAAAAAAAAEAEBECISIxUXGB/9oACAEBAAY/ArGGzxRFfCbU1GfU/8QAGhAAAgMBAQAAAAAAAAAAAAAAAAERIUExcf/aAAgBAQABPyHrE3WImd80ulLyIjSVsu6VInt6P//aAAwDAQACAAMAAAAQ2B//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEQH/2gAIAQMBAT8Qia//xAAVEQEBAAAAAAAAAAAAAAAAAAAQQf/aAAgBAgEBPxCB/8QAHRABAQADAAIDAAAAAAAAAAAAAREAIVExQYGRof/aAAgBAQABPxBdPqhtHXh5hMS3FFn7gtJC7dgencRkEyIathPRlixR+nHCc0tPC/Gf/9k=\'); background-size: cover; display: block;"\n  ></span>\n  <img\n        class="gatsby-resp-image-image"\n        alt="Photo of Typewriter by Pereanu Sebastian"\n        title="Photo of Typewriter by Pereanu Sebastian"\n        src="/blog/static/91985b102e11e1a9b8ac2de71cb5733e/1c72d/typewriter.jpg"\n        srcset="/blog/static/91985b102e11e1a9b8ac2de71cb5733e/a80bd/typewriter.jpg 148w,\n/blog/static/91985b102e11e1a9b8ac2de71cb5733e/1c91a/typewriter.jpg 295w,\n/blog/static/91985b102e11e1a9b8ac2de71cb5733e/1c72d/typewriter.jpg 590w,\n/blog/static/91985b102e11e1a9b8ac2de71cb5733e/a8a14/typewriter.jpg 885w,\n/blog/static/91985b102e11e1a9b8ac2de71cb5733e/fbd2c/typewriter.jpg 1180w,\n/blog/static/91985b102e11e1a9b8ac2de71cb5733e/e5166/typewriter.jpg 1200w"\n        sizes="(max-width: 590px) 100vw, 590px"\n        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"\n        loading="lazy"\n        decoding="async"\n      />\n  </a>\n    </span>'}}),"\n",l.createElement(t.p,null,"Have you ever heard the story of the QWERTY layout on a keyboard? The ",l.createElement(t.a,{href:"https://en.wikipedia.org/wiki/Typewriter#QWERTY"},"popular legend")," is that it was too easy to type if the letters were arranged alphabetically, and this caused mechanical typewriters to jam. The most common letters were too close together, supposedly. So to fix this, the QWERTY layout was invented, to ",l.createElement(t.em,null,"slow down the typist"),"."),"\n",l.createElement(t.p,null,"This Dilbertian engineering idea is eerily similar to what a debounce function does."),"\n",l.createElement(t.h2,null,"What is a debounce?"),"\n",l.createElement(t.p,null,"A debounce function is meant to slow down something in your application, typically a function call. The best way to wrap your head around this is by example."),"\n",l.createElement(t.p,null,"Consider this: you have a search input on your site somewhere, and ",l.createElement(t.em,null,"as the user types"),", you want to go fetch some search results to try and match what the user is looking for before they finish typing."),"\n",l.createElement(t.p,null,l.createElement(t.em,null,"Piece of cake!"),", you think. With React, you can attach your API call to your input‚Äôs ",l.createElement(t.code,null,"onChange")," event like so:"),"\n",l.createElement(t.pre,{"react-live":!0},l.createElement(t.code,{className:"language-jsx"},'function SearchForm() {\n  const [inputVal, setInputVal] = React.useState("")\n  const [callCount, setCallCount] = React.useState(0)\n\n  function handleChange(e) {\n    setInputVal(e.target.value)\n    // let\'s say this was an API call\n    // to add auto-complete data\n    setCallCount(callCount + 1)\n  }\n\n  return (\n    <div>\n      <h2>Type in this Box ‚¨áÔ∏è</h2>\n      <input onChange={handleChange} value={inputVal}/>\n      <p>Current Data: {inputVal}</p>\n      <p>Calls Done: {callCount}</p>\n    </div>\n  )\n}\n')),"\n",l.createElement(t.p,null,"Notice that as you type in the search box, if your API function is attached to your input‚Äôs ",l.createElement(t.code,null,"onChange")," event, you‚Äôll make an API call ",l.createElement(t.em,null,"every time the user presses a key")," üò±. If you couple this with the small delay it takes to make an API call, you can imagine the traffic jam that this would cause as you have multiple API calls being made and flooding back in."),"\n",l.createElement(t.p,null,"This isn‚Äôt what we imagined when we first cooked up this auto-populating search box scheme. What we ",l.createElement(t.em,null,"really")," want to do is to make our API call when the user pauses or stops typing."),"\n",l.createElement(t.p,null,"This is the purpose of a ",l.createElement(t.strong,null,"debounce")," function, to limit the amount of calls that can happen in a given amount of time."),"\n",l.createElement(t.h2,null,"How to debounce a function in JavaScript"),"\n",l.createElement(t.p,null,"So we need to fire fewer API calls, but how do we do it?"),"\n",l.createElement(t.p,null,"Before we jump into React, let‚Äôs give this a shot with regular JavaScript. Let‚Äôs put our fake API call in its own function, then wrap it in our debounce function."),"\n",l.createElement(t.pre,{"js-live":!0},l.createElement(t.code,{className:"language-js"},'let callCount = 0\n\n// this is just a promise that resolves after 300ms\n// and console logs a counter\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      callCount++\n      console.log("Calls Made:" + callCount)\n      resolve()\n    }, 300)\n  })\n}\n\nfakeAPICall() // 1\nfakeAPICall() // 2\nfakeAPICall() // 3\n\nfunction debounce(callback) {\n    // each call to debounce creates a new timeoutId\n    let timeoutId\n    return function() {\n      // this inner function keeps a reference to\n      // timeoutId from the function outside of it\n      clearTimeout(timeoutId)\n      timeoutId = setTimeout(callback, 800)\n    }\n}\n\n// wraps the fakeAPICall function and returns\n// a function that calls fakeAPICall\nconst debouncedFakeApiCall = debounce(fakeAPICall)\n\n// all these calls cancel each other\n// Until the last call finally happens after 800 ms\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall()\ndebouncedFakeApiCall() // 4\n')),"\n",l.createElement(t.p,null,"Success!"),"\n",l.createElement(t.p,null,"Without a debounce, we get 3 calls, but with a debounce, we only fire an API call ",l.createElement(t.strong,null,"on the last function call"),"."),"\n",l.createElement(t.h3,null,"How it works"),"\n",l.createElement(t.p,null,"The most basic, critical piece of this debounce function is to delay the actual API call, then as more calls come in, cancel and reset the delay for the API call. We do this with ",l.createElement(t.code,null,"setTimeout")," and ",l.createElement(t.code,null,"clearTimeout")," in the JavaScript above."),"\n",l.createElement(t.p,null,"If you noticed the debounce function taking a function and returning a another function, that is an example of a closure in JavaScript. When we debounce a function, we pass our original function in, and wrap it in another function that delays calls to the original. In this way our debounce function is reusable throughout our program. We could debounce as many different functions as we want, ",l.createElement(t.strong,null,"because each one has its own ",l.createElement(t.code,null,"timeoutId")," variable"),"."),"\n",l.createElement(t.h2,null,"How to write a debounce function in React"),"\n",l.createElement(t.p,null,"React allows us to encapsulate logic in components, so we can skip the fancy JavaScript closures and just use our component to write a debounce function."),"\n",l.createElement(t.p,null,"Let‚Äôs take a look:"),"\n",l.createElement(t.pre,{"react-live":!0,"use-render":!0},l.createElement(t.code,{className:"language-jsx"},'// just an async helper\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(resolve, 300)\n  })\n}\n\nfunction SearchForm() {\n  const [inputVal, setInputVal] = React.useState("")\n  const [query, setQuery] = React.useState("")\n  const inputRef = React.useRef("")\n  const [callCount, setCallCount] = React.useState(0)\n  const timeoutId = React.useRef()\n\n  function handleChange(e) {\n    setInputVal(e.target.value)\n    // mimic the value so we can access\n    // the latest value in our API call\n    inputRef.current = e.target.value\n  }\n\n  React.useEffect(() => {\n    // if the user keeps typing, stop the API call!\n    clearTimeout(timeoutId.current)\n    // don\'t make an API call with no data\n    if (!inputVal.trim()) return\n    // capture the timeoutId so we can\n    // stop the call if the user keeps typing\n    timeoutId.current = setTimeout(() => {\n      // grab our query, but store it in state so\n      // I can show it to you below in the example üòÑ\n      setQuery(inputRef.current)\n      fakeAPICall()\n      // here we pass a callback so we get the current callCount value\n      // from the useState hook\'s setter function\n      // we use a Ref for timeoutId to avoid this same problem\n      .then(() => setCallCount(callCount => callCount + 1))\n    }, 800)\n  }, [inputVal])\n\n  return (\n    <div>\n      <h2>Type in this Box ‚¨áÔ∏è</h2>\n      <input onChange={handleChange} value={inputVal}/>\n      <p>Current Data: {inputVal}</p>\n      <p>Query Sent: {query}</p>\n      <p>Calls Done: {callCount}</p>\n    </div>\n  )\n}\n\nrender(SearchForm)\n')),"\n",l.createElement(t.p,null,"Now as we type, the component won‚Äôt actually make any API calls until the typing stops."),"\n",l.createElement(t.p,null,"The only difference here is that instead of writing a closure, we‚Äôre using a React Ref for our ",l.createElement(t.code,null,"timeoutId"),". Refs are React‚Äôs version of instance variables, so each SearchForm component that we make should get its own ",l.createElement(t.code,null,"timeoutId"),". If you want to learn more about Refs and ",l.createElement(t.code,null,"useEffect"),", ",l.createElement(t.a,{href:"https://leewarrick.com/blog/react-use-effect-explained/"},"I wrote another post on that topic"),"."),"\n",l.createElement(t.h2,null,"What is a throttle?"),"\n",l.createElement(t.p,null,"This might not be exactly what you imagined when you envisioned this functionality. For example, as you type into Google search, you still get autocomplete suggestions as you type, even if you haven‚Äôt stopped typing."),"\n",l.createElement(t.p,null,"So while our previous examples will ensure we do the ",l.createElement(t.em,null,"fewest")," API calls possible, we may want to tweak our solution to ",l.createElement(t.strong,null,"make an API call every so often as the user types"),". This would be a ",l.createElement(t.strong,null,"throttle")," function."),"\n",l.createElement(t.h2,null,"How to write a throttle in JavaScript"),"\n",l.createElement(t.p,null,"Let‚Äôs tweak our JavaScript debounce implementation so that we only make our API call every 800ms."),"\n",l.createElement(t.pre,{"js-live":!0},l.createElement(t.code,{className:"language-js"},"let callCount = 0\n\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(() => {\n      callCount++\n      console.log(\"Calls Made:\" + callCount)\n      resolve()\n    }, 300)\n  })\n}\n\nfunction throttle(cb) {\n    let makingCall\n    return function() {\n      // if I'm in progress of making an API call,\n      // don't trigger another one\n      if (makingCall) return\n      // set up API call to fire\n      makingCall = true\n      // give the user some time to type by delaying the actual call\n      setTimeout(() => {\n        makingCall = false\n        cb()\n      }, 800)\n    }\n}\n\nconst throttledFakeApiCall = throttle(fakeAPICall)\n\n// imagine the user starting and stopping typing\n// we'll only make a call every 800ms\nthrottledFakeApiCall() // 1\nthrottledFakeApiCall()\nthrottledFakeApiCall()\nsetTimeout(() => {\n  throttledFakeApiCall()\n  throttledFakeApiCall()\n}, 600)\nsetTimeout(() => {\n  throttledFakeApiCall() // 2\n  throttledFakeApiCall()\n}, 1200)\nsetTimeout(() => {\n  throttledFakeApiCall()\n  throttledFakeApiCall()\n}, 1800)\nsetTimeout(() => {\n  throttledFakeApiCall() // 3\n  throttledFakeApiCall()\n}, 2400)\n\n")),"\n",l.createElement(t.p,null,"Now as our throttle function fires, we are limiting our calls to happen every 800ms."),"\n",l.createElement(t.h3,null,"How it works"),"\n",l.createElement(t.p,null,"This new version uses a simple ",l.createElement(t.code,null,"true"),"/",l.createElement(t.code,null,"false")," value to determine if we should trigger more calls instead of clearing the timeout and cancelling previous calls. Now the first call to the throttled function tees up the call, and the subsequent calls are ignored until the API call is complete."),"\n",l.createElement(t.h2,null,"How to write a throttle in React"),"\n",l.createElement(t.p,null,"Let‚Äôs apply this same functionality to our previous React example."),"\n",l.createElement(t.pre,{"react-live":!0,"use-render":!0},l.createElement(t.code,{className:"language-jsx"},'// just an async helper\nfunction fakeAPICall() {\n  return new Promise(resolve => {\n    setTimeout(resolve, 300)\n  })\n}\n\nfunction SearchForm() {\n  const [inputVal, setInputVal] = React.useState("")\n  const [query, setQuery] = React.useState("")\n  const inputRef = React.useRef("")\n  const [callCount, setCallCount] = React.useState(0)\n  const makingCall = React.useRef(false)\n\n  function handleChange(e) {\n    setInputVal(e.target.value)\n    // mimic the value so we can access\n    // the latest value in our API call\n    inputRef.current = e.target.value\n  }\n\n  React.useEffect(() => {\n    // if there\'s no value or we\'ve already triggered a call\n    // prevent further calls\n    if (!inputVal.trim() || makingCall.current) return\n    makingCall.current = true\n    setTimeout(() => {\n      makingCall.current = false\n      // again, this setQuery is just so I can\n      // render the query below.\n      // if this API call were real, we\'d probably\n      // pass the query into the API call function\n      setQuery(inputRef.current)\n      fakeAPICall()\n      .then(() => {\n        setCallCount(callCount => callCount + 1)\n      })\n    }, 800)\n  }, [inputVal])\n\n  return (\n    <div>\n      <h2>Type in this Box ‚¨áÔ∏è</h2>\n      <input onChange={handleChange} value={inputVal}/>\n      <p>Current Data: {inputVal}</p>\n      <p>Query Sent: {query}</p>\n      <p>Calls Done: {callCount}</p>\n    </div>\n  )\n}\n\nrender(SearchForm)\n')),"\n",l.createElement(t.p,null,"Success! Now as the user types, every 800ms we make a call for an autocomplete suggestion. This means ",l.createElement(t.strong,null,"more API calls, but better user experience"),", at least in the case of our search autocomplete example."),"\n",l.createElement(t.h2,null,"Parting Thoughts"),"\n",l.createElement(t.p,null,"So there you have it: throttling and debounce functions in JS and React."),"\n",l.createElement(t.p,null,"But would you ever implement this yourself in real life?"),"\n",l.createElement(t.p,null,"Sure! If you just needed simple functionality like this, you could absolutely manage your own debounce logic/helpers in your app. However, there‚Äôs no shame in pulling in Lodash and using the ",l.createElement(t.a,{href:"https://lodash.com/docs/4.17.15#debounce"},"debounce")," or ",l.createElement(t.a,{href:"https://lodash.com/docs/4.17.15#throttle"},"throttle")," functions that they‚Äôve implemented."),"\n",l.createElement(t.p,null,"I find it fun to try and implement my own solutions, and I think it‚Äôs worth the mental gymnastics to give this stuff a shot in your own code every once in a while. But don‚Äôt be fooled, nobody will judge you if you reach for a third-party solution!"))}var r=function(e){void 0===e&&(e={});const{wrapper:t}=Object.assign({},(0,a.ah)(),e.components);return t?l.createElement(t,e,l.createElement(o,e)):o(e)},i=n(1883),c=n(4915),s=n(2899),u=n(8183),A=n(9175);function h(e){const t=e.data.mdx,n=e.data.site.siteMetadata.title,{previous:a,next:o}=e.pageContext;return l.createElement(s.Z,{location:e.location,title:n},l.createElement(u.Z,{title:t.frontmatter.title,description:t.excerpt,twitterImageUrl:e.data.site.siteMetadata.siteUrl+e.pageContext.slug+"twitter-card.jpg",twitterImageAltText:"Card with Author Portrait Logo Titled: "+e.data.mdx.frontmatter.title+" written by "+e.data.site.siteMetadata.author+" on "+e.data.site.siteMetadata.title}),l.createElement("h1",{style:{marginTop:(0,A.qZ)(2.5)}},t.frontmatter.title),l.createElement("p",{style:{...(0,A.bA)(-.2),display:"block",marginBottom:(0,A.qZ)(1),marginTop:(0,A.qZ)(-1)}},t.frontmatter.date),e.children,l.createElement("hr",{style:{marginBottom:(0,A.qZ)(1)}}),l.createElement(c.Z),l.createElement("ul",{style:{display:"flex",flexWrap:"wrap",justifyContent:"space-between",listStyle:"none",padding:0}},l.createElement("li",null,a&&l.createElement(i.Link,{to:a.fields.slug,rel:"prev"}," ‚Üê ",a.frontmatter.title)),l.createElement("li",null,o&&l.createElement(i.Link,{to:o.fields.slug,rel:"next"},o.frontmatter.title," ‚Üí"))))}function p(e){return l.createElement(h,e,l.createElement(r,e))}}}]);
//# sourceMappingURL=component---src-templates-blog-post-js-content-file-path-home-lee-dev-side-projects-blog-content-blog-how-to-debounce-index-md-506c17fde43941ffbfdc.js.map