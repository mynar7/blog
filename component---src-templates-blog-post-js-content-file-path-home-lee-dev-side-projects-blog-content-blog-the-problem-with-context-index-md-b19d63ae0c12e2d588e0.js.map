{"version":3,"file":"component---src-templates-blog-post-js-content-file-path-home-lee-dev-side-projects-blog-content-blog-the-problem-with-context-index-md-b19d63ae0c12e2d588e0.js","mappings":"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","sources":["webpack://blog/./content/blog/the-problem-with-context/index.md","webpack://blog/./src/templates/blog-post.js"],"sourcesContent":["/*@jsxRuntime classic @jsx React.createElement @jsxFrag React.Fragment*/\nimport {useMDXComponents as _provideComponents} from \"@mdx-js/react\";\nimport React from \"react\";\nfunction _createMdxContent(props) {\n  const _components = Object.assign({\n    div: \"div\",\n    p: \"p\",\n    h2: \"h2\",\n    pre: \"pre\",\n    code: \"code\",\n    a: \"a\",\n    em: \"em\",\n    strong: \"strong\",\n    h3: \"h3\",\n    ol: \"ol\",\n    li: \"li\"\n  }, _provideComponents(), props.components);\n  return React.createElement(React.Fragment, null, React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<span\\n      class=\\\"gatsby-resp-image-wrapper\\\"\\n      style=\\\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \\\"\\n    >\\n      <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/e32a85ecdd68cc08c7896513261f347b/e5166/gorilla.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n    <span\\n    class=\\\"gatsby-resp-image-background-image\\\"\\n    style=\\\"padding-bottom: 66.89189189189189%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAGQAAAQUAAAAAAAAAAAAAAAAAAAEDBAUG/8QAFQEBAQAAAAAAAAAAAAAAAAAAAQD/2gAMAwEAAhADEAAAAWUIBaoqwf/EABsQAAMAAgMAAAAAAAAAAAAAAAECAwAREiEy/9oACAEBAAEFAq1LYtTI7zjtG9A9f//EABYRAQEBAAAAAAAAAAAAAAAAAAAREv/aAAgBAwEBPwGtv//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ASf/xAAZEAACAwEAAAAAAAAAAAAAAAAAEQEQMSH/2gAIAQEABj8CWHKTwiv/xAAcEAEAAgEFAAAAAAAAAAAAAAABABExIUFRscH/2gAIAQEAAT8hSDYZjinneawcXHyiWSvEVF9z/9oADAMBAAIAAwAAABCk3//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPxBa7H//xAAVEQEBAAAAAAAAAAAAAAAAAAABAP/aAAgBAgEBPxBCMl//xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhMVFhkaH/2gAIAQEAAT8Q7QEcpAa0FoseIBBwDXFkQnU47Bovf2NQqAB1FSygG0//2Q=='); background-size: cover; display: block;\\\"\\n  ></span>\\n  <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        alt=\\\"A Gorilla looking thoughtful by Rob Schreckhise\\\"\\n        title=\\\"A Gorilla looking thoughtful by Rob Schreckhise\\\"\\n        src=\\\"/static/e32a85ecdd68cc08c7896513261f347b/1c72d/gorilla.jpg\\\"\\n        srcset=\\\"/static/e32a85ecdd68cc08c7896513261f347b/a80bd/gorilla.jpg 148w,\\n/static/e32a85ecdd68cc08c7896513261f347b/1c91a/gorilla.jpg 295w,\\n/static/e32a85ecdd68cc08c7896513261f347b/1c72d/gorilla.jpg 590w,\\n/static/e32a85ecdd68cc08c7896513261f347b/a8a14/gorilla.jpg 885w,\\n/static/e32a85ecdd68cc08c7896513261f347b/fbd2c/gorilla.jpg 1180w,\\n/static/e32a85ecdd68cc08c7896513261f347b/e5166/gorilla.jpg 1200w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n        style=\\\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\\\"\\n        loading=\\\"lazy\\\"\\n        decoding=\\\"async\\\"\\n      />\\n  </a>\\n    </span>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, \"React’s context API is awesome. As someone that looked at Redux as a junior developer and instantly felt defeated, learning about context was a relief. I used it in my apps, quickly forgot about Redux, and never looked back.\"), \"\\n\", React.createElement(_components.p, null, \"That is, until I heard about the supposed performance problems with the Context API. Now, the big names in the React community will tell you not to worry about performance unless you start seeing issues. And yet, I keep hearing about context problems from other developers. One fellow even mentioned his boss banning the use of Context on their project.\"), \"\\n\", React.createElement(_components.p, null, \"Let’s review the Context API in case you’re unfamiliar before we talk about its problems.\"), \"\\n\", React.createElement(_components.h2, null, \"Why use the context API?\"), \"\\n\", React.createElement(_components.p, null, \"The Context API is useful for sharing state between components that you can’t easily share with props. Here’s an example of a button component that needs to set the state of a distant ancestor:\"), \"\\n\", React.createElement(_components.pre, {\n    \"react-live\": true,\n    \"use-render\": true\n  }, React.createElement(_components.code, {\n    className: \"language-jsx\"\n  }, \"const { useState } = React\\n\\nfunction CountDisplay({ count }) {\\n  return <h2>The Count is: {count}</h2>\\n}\\n\\nfunction CountButton({ setCount }) {\\n  return (\\n    <button onClick={() => setCount(count => count + 1)}>\\n      Increment\\n    </button>\\n  )\\n}\\n\\nconst OuterWrapper = ({setCount}) => <InnerWrapper setCount={setCount}/>\\nconst InnerWrapper = ({setCount}) => <CountButton setCount={setCount}/>\\n\\nfunction App() {\\n  const [count, setCount] = useState(0)\\n  return (\\n    <div>\\n      <CountDisplay count={count} />\\n      <OuterWrapper setCount={setCount}/>\\n    </div>\\n  )\\n}\\n\\nrender(App)\\n\")), \"\\n\", React.createElement(_components.p, null, \"The button component is within a few other components further down the tree, but still needs to access state from higher up in the app. So we have to pass \", React.createElement(_components.code, null, \"setCount\"), \" down to each component to finally get it to our \", React.createElement(_components.code, null, \"CountButton\"), \" component. This is affectionately known as “prop-drilling”, and used to be a huge pain point in React.\"), \"\\n\", React.createElement(_components.p, null, \"The Context API makes short work of situations like this, thankfully.\"), \"\\n\", React.createElement(_components.h2, null, \"How to use the Context API\"), \"\\n\", React.createElement(_components.p, null, \"Kent C. Dodds has a fantastic \", React.createElement(_components.a, {\n    href: \"https://kentcdodds.com/blog/application-state-management-with-react\"\n  }, \"blog post\"), \" that I refer to whenever I implement the Context API. If you don’t have time to read that, here’s the short version: Context is a way to share state between unrelated or distant components. All you have to do is wrap your components in a \", React.createElement(_components.code, null, \"Context.Provider\"), \" and then call \", React.createElement(_components.code, null, \"useContext(Context)\"), \" inside that component to access your state and helper functions.\"), \"\\n\", React.createElement(_components.p, null, \"Here’s our counter example with context:\"), \"\\n\", React.createElement(_components.pre, {\n    \"react-live\": true,\n    \"use-render\": true\n  }, React.createElement(_components.code, {\n    className: \"language-jsx\"\n  }, \"const {useContext, useState, createContext} = React\\n\\nconst AppContext = createContext()\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const value = { count, setCount }\\n  return (\\n    <AppContext.Provider value={value}>\\n      {props.children}\\n    </AppContext.Provider>\\n  )\\n}\\n\\nfunction CountDisplay() {\\n  const { count } = useContext(AppContext)\\n  return <h2>The Count is: {count}</h2>\\n}\\n\\nfunction CountButton() {\\n  const { setCount } = useContext(AppContext)\\n  return (\\n    <button onClick={() => setCount(count => count + 1)}>\\n      Increment\\n    </button>\\n  )\\n}\\n\\nconst OuterWrapper = () => <InnerWrapper />\\n\\nconst InnerWrapper = () => <CountButton />\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <CountDisplay/>\\n        <OuterWrapper/>\\n      </AppProvider>\\n    </div>\\n  )\\n}\\n\\nrender(App)\\n\")), \"\\n\", React.createElement(_components.p, null, \"Here we have \", React.createElement(_components.code, null, \"CountDisplay\"), \" and \", React.createElement(_components.code, null, \"CountButton\"), \" components that both need to interact with the higher-level \", React.createElement(_components.code, null, \"count\"), \" state in our context. We start by making a context with \", React.createElement(_components.code, null, \"createContext\"), \", then a provider component in \", React.createElement(_components.code, null, \"AppProvider\"), \" to wrap our dependent components, and finally call \", React.createElement(_components.code, null, \"useContext\"), \" in each component to pull out the values we need. It doesn’t matter how far apart the components are as long as they’re wrapped in a provider.\"), \"\\n\", React.createElement(_components.p, null, \"Pretty great right?\"), \"\\n\", React.createElement(_components.h2, null, \"Kent C. Dodd’s Optimizations 📈\"), \"\\n\", React.createElement(_components.p, null, \"We can improve on this a little bit by implementing some stuff that Kent has in his article on state management. Let’s take a look:\"), \"\\n\", React.createElement(_components.pre, {\n    \"react-live\": true,\n    \"use-render\": true\n  }, React.createElement(_components.code, {\n    className: \"language-jsx\"\n  }, \"const {useContext, useState, createContext, useMemo} = React\\nconst AppContext = createContext()\\n\\n// instead of calling useContext directly in our components,\\n// we make our own hook that throws an error if we try to\\n// access context outside of the provider\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context)\\n    throw new Error('AppContext must be used with AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  // here we use useMemo for... reasons.\\n  // this says don't give back a new count/setCount unless count changes\\n  const value = useMemo(() => ({ count, setCount }), [count])\\n  return <AppContext.Provider value={value} {...props} />\\n}\\n\\nfunction CountDisplay() {\\n  const { count } = useAppContext()\\n  return <h2>The Count is: {count}</h2>\\n}\\n\\nfunction CountButton() {\\n  const { setCount } = useAppContext()\\n  return (\\n    <button onClick={() => setCount(count => count + 1)}>\\n      Increment\\n    </button>\\n  )\\n}\\n\\nconst OuterWrapper = () => <InnerWrapper />\\n\\nconst InnerWrapper = () => <CountButton />\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <CountDisplay />\\n        <OuterWrapper />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\n\\nrender(App)\\n\")), \"\\n\", React.createElement(_components.p, null, \"The first thing we do is throw an error if we try to access the context outside of our provider. This is a great idea to improve the developer experience of your app (aka: make the console scream at you when you forget how context works).\"), \"\\n\", React.createElement(_components.p, null, \"The second thing is to memoize our context value to only re-render if the \", React.createElement(_components.code, null, \"count\"), \" changes. Now, \", React.createElement(_components.code, null, \"useMemo\"), \" is a difficult thing to wrap your head around, but the basic gist is that when you memoize something, you’re saying that you won’t return that value again unless your specified value changes. Kent has a \", React.createElement(_components.a, {\n    href: \"https://kentcdodds.com/blog/usememo-and-usecallback\"\n  }, \"great article\"), \" on that too if you want to read more.\"), \"\\n\", React.createElement(_components.p, null, \"I can’t discern a difference between using \", React.createElement(_components.code, null, \"useMemo\"), \" and not using it, but I would venture that if you’re doing some heavy lifting in your Context Provider, it might be beneficial to apply memoization. If you read Kent’s article on \", React.createElement(_components.code, null, \"useMemo\"), \" and \", React.createElement(_components.code, null, \"useCallback\"), \" he cautions against using them unless you start to see performance hits. (Full Disclosure: I’ve never needed to use either one.)\"), \"\\n\", React.createElement(_components.p, null, \"Kent also spreads his \", React.createElement(_components.code, null, \"props\"), \" on the provider instead of using \", React.createElement(_components.code, null, \"props.children\"), \", which is a neat trick, so I included that as well.\"), \"\\n\", React.createElement(_components.h2, null, \"The Context API’s Dirty Little Secret 🤫\"), \"\\n\", React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<span\\n      class=\\\"gatsby-resp-image-wrapper\\\"\\n      style=\\\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \\\"\\n    >\\n      <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/e5166/trashman.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n    <span\\n    class=\\\"gatsby-resp-image-background-image\\\"\\n    style=\\\"padding-bottom: 100%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAUABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAEDBAL/xAAWAQEBAQAAAAAAAAAAAAAAAAABAAL/2gAMAwEAAhADEAAAActro1nSK2SsgT//xAAZEAACAwEAAAAAAAAAAAAAAAABAgARIRL/2gAIAQEAAQUCsBMhTQOgclmI1RzcUdD/xAAVEQEBAAAAAAAAAAAAAAAAAAAQAf/aAAgBAwEBPwEp/8QAFREBAQAAAAAAAAAAAAAAAAAAEAH/2gAIAQIBAT8BIf/EAB4QAAAFBQEAAAAAAAAAAAAAAAABECExAhESQVGR/9oACAEBAAY/AsSk98WzJCVeBx//xAAbEAEAAgMBAQAAAAAAAAAAAAABACERMVFhQf/aAAgBAQABPyEyWOl7ExQ832PliPhnWrmdAX6ws3jKpcIbB5LJPKqf/9oADAMBAAIAAwAAABDE8MH/xAAYEQADAQEAAAAAAAAAAAAAAAAAAREQMf/aAAgBAwEBPxCxkR1n/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAEQETH/2gAIAQIBAT8Q1FuDP//EAB8QAQACAgEFAQAAAAAAAAAAAAERIQAxQVFhkcHRsf/aAAgBAQABPxCYiuZ0HafuNGVAKcYWDKlr8xwq8jRz4yahW5NGkn1krSGkX04FYTEa6p5xykgi4Ftd6yYKR6LR9z//2Q=='); background-size: cover; display: block;\\\"\\n  ></span>\\n  <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        alt=\\\"Man making the shush gesture with his finger over his lip, laying on a mound of trash. Photo by Jordan Beltran\\\"\\n        title=\\\"Man making the shush gesture with his finger over his lip, laying on a mound of trash. Photo by Jordan Beltran\\\"\\n        src=\\\"/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/1c72d/trashman.jpg\\\"\\n        srcset=\\\"/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/a80bd/trashman.jpg 148w,\\n/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/1c91a/trashman.jpg 295w,\\n/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/1c72d/trashman.jpg 590w,\\n/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/a8a14/trashman.jpg 885w,\\n/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/fbd2c/trashman.jpg 1180w,\\n/static/d204d0e47f5b8ef1bb8bcbba4ab82fa3/e5166/trashman.jpg 1200w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n        style=\\\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\\\"\\n        loading=\\\"lazy\\\"\\n        decoding=\\\"async\\\"\\n      />\\n  </a>\\n    </span>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, \"Boy, the Context API sure is great. It’s super easy to use compared to Redux and requires a lot less code, so why \", React.createElement(_components.em, null, \"wouldn’t\"), \" you use it?\"), \"\\n\", React.createElement(_components.p, null, \"The problem with context is simple: \", React.createElement(_components.strong, null, \"Everything that consumes a context re-renders everytime that context’s state changes.\")), \"\\n\", React.createElement(_components.p, null, \"That means that if you’re consuming your context all over the place in your app, or worse, using one context for your entire app’s state, you’re causing a ton of re-renders all over the place!\"), \"\\n\", React.createElement(_components.p, null, \"Let’s visualize this with a simple app. Let’s make a context with a counter and a message. The message will never change, but be consumed by three components that display the message in a random color on each render. The count will be consumed by one component, and be the only value that changes.\"), \"\\n\", React.createElement(_components.p, null, \"That sounds like a middle school math problem, but if you look at this code and the resulting app, the problem becomes blatantly obvious:\"), \"\\n\", React.createElement(_components.pre, {\n    \"react-live\": true,\n    \"use-render\": true\n  }, React.createElement(_components.code, {\n    className: \"language-jsx\"\n  }, \"const {useContext, useState, createContext} = React\\nconst AppContext = createContext()\\n\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context)\\n    throw new Error('useAppContext must be used within AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  // the count for our counter component\\n  const [count, setCount] = useState(0)\\n  // this message never changes!\\n  const [message, setMessage] = useState('Hello from Context!')\\n  const value = {\\n    count,\\n    setCount,\\n    message,\\n    setMessage\\n  }\\n  return <AppContext.Provider value={value} {...props}/>\\n}\\n\\nfunction Message() {\\n  const { message } = useAppContext()\\n  // the text will render to a random color for\\n  // each instance of the Message component\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useAppContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <h2>Re-renders! 😩</h2>\\n        <Message />\\n        <Message />\\n        <Message />\\n        <Count />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), \"\\n\", React.createElement(_components.p, null, \"Everything re-renders when we click increment 😱.\"), \"\\n\", React.createElement(_components.p, null, \"The message components don’t even use the \", React.createElement(_components.code, null, \"count\"), \" from our context, but they re-render anyway. Yikes!\"), \"\\n\", React.createElement(_components.h3, null, \"What about memoization?\"), \"\\n\", React.createElement(_components.p, null, \"Maybe we just forgot to use \", React.createElement(_components.code, null, \"useMemo\"), \" like Kent did in his example. Let’s memoize our context and see what happens:\"), \"\\n\", React.createElement(_components.pre, {\n    \"react-live\": true,\n    \"use-render\": true\n  }, React.createElement(_components.code, {\n    className: \"language-jsx\"\n  }, \"const {useContext, useState, createContext, useMemo} = React\\nconst AppContext = createContext()\\n\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context) throw new Error('useAppContext must be used within AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const [message, setMessage] = useState('Hello from Context!')\\n  // here we pass our value to useMemo,\\n  // and tell useMemo to only give us new values\\n  // when count or message change\\n  const value = useMemo(() => ({\\n    count,\\n    setCount,\\n    message,\\n    setMessage\\n  }), [count, message])\\n  return <AppContext.Provider value={value} {...props}/>\\n}\\n\\nfunction Message() {\\n  const { message } = useAppContext()\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useAppContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <h2>Re-renders! 😩</h2>\\n        <Message />\\n        <Message />\\n        <Message />\\n        <Count />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), \"\\n\", React.createElement(_components.p, null, \"Nope! Memoization with \", React.createElement(_components.code, null, \"useMemo\"), \" doesn’t help at all!\"), \"\\n\", React.createElement(_components.h3, null, \"What about components that don’t consume Context, do they re-render?\"), \"\\n\", React.createElement(_components.p, null, \"That’s an excellent question, let’s test it with a Message component that doesn’t consume context:\"), \"\\n\", React.createElement(_components.pre, {\n    \"react-live\": true,\n    \"use-render\": true\n  }, React.createElement(_components.code, {\n    className: \"language-jsx\"\n  }, \"const {useContext, useState, createContext, useMemo} = React\\nconst AppContext = createContext()\\n\\nfunction useAppContext() {\\n  const context = useContext(AppContext)\\n  if (!context) throw new Error('useAppContext must be used within AppProvider!')\\n  return context\\n}\\n\\nfunction AppProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const [message, setMessage] = useState('Hello from Context!')\\n  const value = useMemo(() => ({\\n    count,\\n    setCount,\\n    message,\\n    setMessage\\n  }), [count, message])\\n  return <AppContext.Provider value={value} {...props}/>\\n}\\n\\n// this component does NOT consume the context\\n// but is still within the Provider component\\nfunction IndependentMessage() {\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>I'm my own Independent Message!</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Message() {\\n  const { message } = useAppContext()\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useAppContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <AppProvider>\\n        <h2>Re-renders! 😩</h2>\\n        <Message />\\n        <Message />\\n        <Message />\\n        <IndependentMessage />\\n        <Count />\\n      </AppProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), \"\\n\", React.createElement(_components.p, null, \"Well, this is the only good news so far. \", React.createElement(_components.strong, null, \"Only components that call \", React.createElement(_components.code, null, \"useContext\"), \" re-render whenever the context’s state changes.\")), \"\\n\", React.createElement(_components.p, null, \"Still, this is bad news for our app. We don’t want to trigger a bunch of unnecessary re-renders everywhere we use a context.\"), \"\\n\", React.createElement(_components.p, null, \"Imagine if those message components were doing a lot of work like calculating animations, or if we had a huge React app with lots of components dependent on our context. That could lead to pretty serious performance issues, right?\"), \"\\n\", React.createElement(_components.h2, null, \"Should we stop using Context?\"), \"\\n\", React.createElement(_components.div, {\n    dangerouslySetInnerHTML: {\n      __html: \"<span\\n      class=\\\"gatsby-resp-image-wrapper\\\"\\n      style=\\\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 590px; \\\"\\n    >\\n      <a\\n    class=\\\"gatsby-resp-image-link\\\"\\n    href=\\\"/static/8c27d995b617560da5b04f46a8069006/e5166/trash.jpg\\\"\\n    style=\\\"display: block\\\"\\n    target=\\\"_blank\\\"\\n    rel=\\\"noopener\\\"\\n  >\\n    <span\\n    class=\\\"gatsby-resp-image-background-image\\\"\\n    style=\\\"padding-bottom: 75%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHmushFB//EABkQAQEAAwEAAAAAAAAAAAAAAAEAERIxQv/aAAgBAQABBQLr5sg7EX//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAAAREg/9oACAEBAAY/AoRZ/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAEhETFB/9oACAEBAAE/IbUPPQ+7gqU24yrr2iQ//9oADAMBAAIAAwAAABATD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQEAAwADAQAAAAAAAAAAAAERACExQVGBkf/aAAgBAQABPxAA6r17DHZJUDuO99s+YJrlBB5MUQ2Il9Q/cKc//9k='); background-size: cover; display: block;\\\"\\n  ></span>\\n  <img\\n        class=\\\"gatsby-resp-image-image\\\"\\n        alt=\\\"Sign showing man throwing away trash, photo by Gary Chan\\\"\\n        title=\\\"Sign showing man throwing away trash, photo by Gary Chan\\\"\\n        src=\\\"/static/8c27d995b617560da5b04f46a8069006/1c72d/trash.jpg\\\"\\n        srcset=\\\"/static/8c27d995b617560da5b04f46a8069006/a80bd/trash.jpg 148w,\\n/static/8c27d995b617560da5b04f46a8069006/1c91a/trash.jpg 295w,\\n/static/8c27d995b617560da5b04f46a8069006/1c72d/trash.jpg 590w,\\n/static/8c27d995b617560da5b04f46a8069006/a8a14/trash.jpg 885w,\\n/static/8c27d995b617560da5b04f46a8069006/fbd2c/trash.jpg 1180w,\\n/static/8c27d995b617560da5b04f46a8069006/e5166/trash.jpg 1200w\\\"\\n        sizes=\\\"(max-width: 590px) 100vw, 590px\\\"\\n        style=\\\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\\\"\\n        loading=\\\"lazy\\\"\\n        decoding=\\\"async\\\"\\n      />\\n  </a>\\n    </span>\"\n    }\n  }), \"\\n\", React.createElement(_components.p, null, \"I’ll go ahead and say this now: \", React.createElement(_components.strong, null, \"no, this isn’t a reason to stop using context\"), \". There’s a ton of apps out there using context and chugging along just fine, including a bunch of my own apps.\"), \"\\n\", React.createElement(_components.p, null, \"Still, performance is kind of a big deal. I don’t want to leave you sitting up at night worrying about the Context API’s dirty little secret. So let’s talk about some ways to deal with this re-render business.\"), \"\\n\", React.createElement(_components.h3, null, \"Option 1: Don’t worry at all. Keep on Context’n like you do. YOLO 🤪!\"), \"\\n\", React.createElement(_components.p, null, \"I’ve basically used Context a whole bunch in a lot of various apps without memoization, at the top level of my app, and consumed by a bunch of components without noticing any performance hits at all. Like I said before, a lot of the React folks say you shouldn’t even worry about performance optimizations until you see performance impacts.\"), \"\\n\", React.createElement(_components.p, null, \"Still, this strategy won’t work for everyone. You may already have performance issues in your app, or if your app processes a lot of logic or animations, you may see performance issues as your app grows and end up doing some serious refactoring down the road.\"), \"\\n\", React.createElement(_components.h3, null, \"Option 2: Use Redux or Mobx\"), \"\\n\", React.createElement(_components.p, null, \"Redux and Mobx both use the context API, so how do they help? The store that’s shared by these state management libraries with context is a little different from sharing state directly with context. When you’re using Redux and Mobx, there’s a diffing algorithm at work that makes sure to only re-render the components that actually need to re-render.\"), \"\\n\", React.createElement(_components.p, null, \"Still, context was supposed to save us from having to learn Redux and Mobx! There’s a lot of abstractions and boilerplate involved in using a state management library, making it an unattractive solution to some folks.\"), \"\\n\", React.createElement(_components.p, null, \"Plus, isn’t keeping all of our state in global state a bad practice?\"), \"\\n\", React.createElement(_components.h3, null, \"Option 3: Use Multiple Contexts, and keep state close to its Dependent Components\"), \"\\n\", React.createElement(_components.p, null, \"This solution takes the most finesse to pull off, but gives you the best performance without reaching for Redux and Mobx. It relies on being smart about your state management choices, and only passing state up to a context if you need to share it between distant components.\"), \"\\n\", React.createElement(_components.p, null, \"There’s a few key tenants to this strategy:\"), \"\\n\", React.createElement(_components.ol, null, \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"Let a component manage its own state if it can.\"), \" This is a good practice to follow regardless of your choice of state management. For example, if you have a modal that needs to keep track of an open/closed state, but no other components need to know if that modal is open, keep that open/closed state in the modal. Don’t push state into context (or Redux) if you don’t have to!\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"If your state is shared between a parent and a few children, just prop it down.\"), \" This is the old school method of sharing state. Just pass it as props to the children components that need it. Passing props or “Prop-drilling” can be miserable with deeply nested components, but if you’re only passing things down a few levels, you should probably just do it.\"), \"\\n\", React.createElement(_components.li, null, React.createElement(_components.strong, null, \"If the previous two things fail, use context but keep it close to the components that depend on it.\"), \" This means if you need to share some state, like a form for instance with multiple components, go ahead and make a separate context for just the form and wrap the form components in your provider.\"), \"\\n\"), \"\\n\", React.createElement(_components.p, null, \"That last one deserves an example. Let’s apply it to our problem app from before. We can fix those re-renders by separating the \", React.createElement(_components.code, null, \"message\"), \" and \", React.createElement(_components.code, null, \"count\"), \" into their own contexts.\"), \"\\n\", React.createElement(_components.pre, {\n    \"react-live\": true,\n    \"use-render\": true\n  }, React.createElement(_components.code, {\n    className: \"language-jsx\"\n  }, \"const { useContext, useState, createContext } = React\\nconst CountContext = createContext()\\n\\n// Now count context only worries about count!\\nfunction useCountContext() {\\n  const context = useContext(CountContext)\\n  if (!context)\\n    throw new Error('useCountContext must be used within CountProvider!')\\n  return context\\n}\\n\\nfunction CountProvider(props) {\\n  const [count, setCount] = useState(0)\\n  const value = { count, setCount }\\n  return <CountContext.Provider value={value} {...props}/>\\n}\\n\\n// And message context only worries about message!\\nconst MessageContext = createContext()\\n\\nfunction useMessageContext() {\\n  const context = useContext(MessageContext)\\n  if (!context)\\n    throw new Error('useMessageContext must be used within MessageProvider!')\\n  return context\\n}\\n\\nfunction MessageProvider(props) {\\n  const [message, setMessage] = useState('Hello from Context!')\\n  const value = { message, setMessage }\\n  return <MessageContext.Provider value={value} {...props}/>\\n}\\n\\nfunction Message() {\\n  const { message } = useMessageContext()\\n  const getColor = () => (Math.floor(Math.random() * 255))\\n  const style = {\\n    color: `rgb(${getColor()},${getColor()},${getColor()})`\\n  }\\n  return (\\n    <div>\\n      <h4 style={style}>{message}</h4>\\n    </div>\\n  )\\n}\\n\\nfunction Count() {\\n  const {count, setCount} = useCountContext()\\n  return (\\n    <div>\\n      <h3>Current count from context: {count}</h3>\\n      <button onClick={() => setCount(count + 1)}>Increment</button>\\n    </div>\\n  )\\n}\\n\\nfunction App() {\\n  return (\\n    <div>\\n      <h2>No Unnecessary Re-renders! 😎</h2>\\n      <MessageProvider>\\n        <Message />\\n        <Message />\\n        <Message />\\n      </MessageProvider>\\n      <CountProvider>\\n        <Count />\\n      </CountProvider>\\n    </div>\\n  )\\n}\\nrender(App)\\n\")), \"\\n\", React.createElement(_components.p, null, \"Now our state is only shared with the components that care about that state. When we increment, the colors of our message components stay the same because \", React.createElement(_components.code, null, \"count\"), \" lives outside of \", React.createElement(_components.code, null, \"messageContext\"), \".\"), \"\\n\", React.createElement(_components.h2, null, \"Final Thoughts\"), \"\\n\", React.createElement(_components.p, null, \"Although this article’s title is a little incendiary and the “problem” with context  may not be the boogie man some might envision it to be, I still think this is worth talking about. React’s flexibility makes it both a great framework for beginners as well as a devastating footgun for those that don’t know its inner-workings. I don’t forsee a lot of people tripping over this particular detail, but if you’re using context and seeing performance issues, it’s a good thing to know!\"));\n}\nfunction MDXContent(props = {}) {\n  const {wrapper: MDXLayout} = Object.assign({}, _provideComponents(), props.components);\n  return MDXLayout ? React.createElement(MDXLayout, props, React.createElement(_createMdxContent, props)) : _createMdxContent(props);\n}\nexport default MDXContent;\n","import GATSBY_COMPILED_MDX from \"/home/lee/dev/side_projects/blog/content/blog/the-problem-with-context/index.md\";\nimport React from 'react';\nimport {Link, graphql} from 'gatsby';\nimport Bio from '../components/Bio';\nimport Layout from '../components/Layout';\nimport SEO from '../components/seo';\nimport {rhythm, scale} from '../utils/typography';\nfunction BlogPostTemplate(props) {\n  const post = props.data.mdx;\n  const siteTitle = props.data.site.siteMetadata.title;\n  const {previous, next} = props.pageContext;\n  return React.createElement(Layout, {\n    location: props.location,\n    title: siteTitle\n  }, React.createElement(SEO, {\n    title: post.frontmatter.title,\n    description: post.excerpt,\n    twitterImageUrl: props.data.site.siteMetadata.siteUrl + props.pageContext.slug + 'twitter-card.jpg',\n    twitterImageAltText: `Card with Author Portrait Logo Titled: ${props.data.mdx.frontmatter.title} written by ${props.data.site.siteMetadata.author} on ${props.data.site.siteMetadata.title}`\n  }), React.createElement(\"h1\", {\n    style: {\n      marginTop: rhythm(2.5)\n    }\n  }, post.frontmatter.title), React.createElement(\"p\", {\n    style: {\n      ...scale(-1 / 5),\n      display: `block`,\n      marginBottom: rhythm(1),\n      marginTop: rhythm(-1)\n    }\n  }, post.frontmatter.date), props.children, React.createElement(\"hr\", {\n    style: {\n      marginBottom: rhythm(1)\n    }\n  }), React.createElement(Bio), React.createElement(\"ul\", {\n    style: {\n      display: `flex`,\n      flexWrap: `wrap`,\n      justifyContent: `space-between`,\n      listStyle: `none`,\n      padding: 0\n    }\n  }, React.createElement(\"li\", null, previous && React.createElement(Link, {\n    to: previous.fields.slug,\n    rel: \"prev\"\n  }, \" ← \", previous.frontmatter.title)), React.createElement(\"li\", null, next && React.createElement(Link, {\n    to: next.fields.slug,\n    rel: \"next\"\n  }, next.frontmatter.title, \" →\"))));\n}\nexport default function GatsbyMDXWrapper(props) {\n  return React.createElement(BlogPostTemplate, props, React.createElement(GATSBY_COMPILED_MDX, props));\n}\nexport const pageQuery = graphql`\n  query ($slug: String!) {\n    site {\n      siteMetadata {\n        title\n        author\n        siteUrl\n      }\n    }\n    mdx(fields: { slug: { eq: $slug } }) {\n      id\n      excerpt(pruneLength: 180)\n      frontmatter {\n        title\n        date(formatString: \"MMMM DD, YYYY\")\n      }\n      body\n    }\n  }\n`;\n"],"names":["_createMdxContent","props","_components","Object","assign","div","p","h2","pre","code","a","em","strong","h3","ol","li","_provideComponents","components","React","dangerouslySetInnerHTML","__html","className","href","wrapper","MDXLayout","BlogPostTemplate","post","data","mdx","siteTitle","site","siteMetadata","title","previous","next","pageContext","Layout","location","SEO","frontmatter","description","excerpt","twitterImageUrl","siteUrl","slug","twitterImageAltText","author","style","marginTop","rhythm","scale","display","marginBottom","date","children","Bio","flexWrap","justifyContent","listStyle","padding","Link","to","fields","rel","GatsbyMDXWrapper","GATSBY_COMPILED_MDX"],"sourceRoot":""}